<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>intro_to_presence_calculus</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<h1 id="the-presence-calculus-a-gentle-introduction">The Presence
Calculus, <br> A Gentle Introduction</h1>
<p><strong>Dr. Krishna Kumar</strong><br />
<em>The Polaris Advisor Program</em></p>
<h2 id="what-is-the-presence-calculus">What is The Presence
Calculus?</h2>
<p>The Presence Calculus is a new approach for reasoning quantitatively
about the<br />
relationships between things and places in a domain over time.</p>
<p>The primary goal is to support rigorous modeling and principled<br />
decision-making with operational data in complex, business-critical
domains.</p>
<p>A key objective was ensuring that the use of data in such decisions
rests on a<br />
mathematically precise, logically coherent, and epistemically
grounded<br />
foundation.</p>
<p>The presence calculus emerged from a search for better quantitative
tools to<br />
reason about software product development and engineering, where
current<br />
approaches leave much to be desired in all three aspects.</p>
<p>Minimally, the foundational constructs of the calculus bring
mathematical<br />
precision to widely used—but poorly defined—concepts such as flow,
stability,<br />
equilibrium, and coherence in a domain. More importantly, it allows us
to<br />
relate them to business-oriented concerns like delay, cost, revenue,
and<br />
user experience.</p>
<p>As you’ll see, however, the ideas behind the calculus are far more
general,<br />
with potential applications well beyond the software product
development<br />
context it emerged from.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pcalc/presence_calculus.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 1: Key constructs—presences, element trajectories, presence matrix,  
and basis topology</code></pre>
</div>
</div>
<h1 id="the-pitch">The pitch</h1>
<p>We introduce the simple but powerful concept of a
<em>presence</em>.</p>
<p>This lets us reason about time, history and evolution using
techniques from measure theory, topology and complex analysis.</p>
<p>Classical statistics and probability theory often struggle here.
<em>History</em>—the sequence and structure of changes in the domain
over time— is usually fenced off under assumptions like ergodicity,
stationarity, and independence.</p>
<p>However, probability theory and statistic remain very powerful tools
for describing local behavior, identifying patterns and correlations in
this behavior, and modeling uncertainty—all crucial aspects of
meaningful analysis of complex systems.</p>
<p>Our thesis is that to move beyond simple descriptive statistics,
statistical inference and probabilistic models, and start reasoning
about global and long run behavior of complex systems, we need models
that treat time and history as first-class concepts we can reason and
compute with.</p>
<p>This, in turn, lets us apply techniques from disciplines such as
stochastic process dynamics, queueing theory, and complex systems
science, to reason holistically about global, long run behavior of
complex systems.</p>
<p>We claim the presence calculus is a novel, constructive approach to
do this - a new and powerful reasoning tool for anyone working with
complex systems.</p>
<p>But this is a bold claim, and it deserves further scrutiny and
validation, and so we invite anyone interested in doing so to
collaborate with us on this open source project.</p>
<h2 id="learning-more-about-the-presence-calculus">Learning more about
The Presence Calculus</h2>
<p>While the calculus was developed with mathematical rigor, an equally
important<br />
goal was not to let mathematics get in the way of understanding the
simple but very powerful and general ideas the calculus embodies<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>In this document, we’ll motivate and introduce the key ideas in the
calculus<br />
informally, with lots of highly evocative examples and simplifications
to<br />
illustrate concepts.</p>
<p>It is aimed squarely at the non-technical reader. We’ll also continue
with ongoing informal exposition on our blog<br />
<a href="https://www.polaris-flow-dispatch.com">The Polaris Flow
Dispatch</a>.</p>
<p>We recommend reading and understanding the ideas here before jumping
deeper<br />
into the rest of the documentation at this site, which does get a fair
bit<br />
more dense. The next level of detail is in the API docs for <a
href="https://py.pcalc.org">The Presence Calculus<br />
Toolkit</a>.</p>
<p>The toolkit is an open source python library that is designed to
provide efficient implementations for all the core concepts in the
presence calculus. In the API documentation, we go into the concepts at
a level of rigor that you’ll need to work with the pcalc API and apply
the concepts. Some mathematical background will be useful here if you
want to develop extend the core.</p>
<p>The toolkit provides a reference implementation of the concepts in
this document, and is designed as an analytical middleware layer
suitable for interfacing real world operational systems and complex
system simulation, to the analytical machinery of the presence
calculus.</p>
<p>Finally, for those who want to dive deeper into the formal
mathematical<br />
underpinnings of the calculus, we have the theory track, which perhaps
goes<br />
into more detail than most people will need to read or understand, but
is<br />
useful for the mathematically trained to connect the ideas to their
roots in<br />
mainstream mathematics.</p>
<p>Let’s jump in…</p>
<h2 id="why-presence">Why Presence?</h2>
<p>Presence is how reality reveals itself.</p>
<p>We do not perceive the world as disjointed events in time, but rather
as an unfolding—things come into being, endure for a time, and slip
away.</p>
<p>Permanence is just a form of lasting presence. What we call
<em>change</em> is the<br />
movement of presences in and out of our awareness, often set against
that<br />
permanence.</p>
<p>The sense of something being present—or no longer present—is our
most<br />
immediate way of detecting change.</p>
<p>This applies to both the tangible—people, places, and things—and
the<br />
intangible—emotions, feelings, and experiences.</p>
<p>Either way, we reason about the world by reasoning about the
presences and<br />
absences in our environment over time.</p>
<p>The presence calculus begins here. Before we count, measure, compare,
or<br />
optimize, we observe what <em>is</em>.</p>
<p>And what we model is presence.</p>
<h2 id="an-example">An example</h2>
<p>Imagine you see a dollar bill on the sidewalk on your way to get
coffee.<br />
Later, on your way back home, you see it again—still lying in the same
spot.<br />
It would be reasonable for you to assume that the dollar bill was
present<br />
there the whole time.</p>
<p>Of course, that may not be true. Someone might have picked it up in
the<br />
meantime, felt guilty, and quietly returned it. But in the absence of
other<br />
information, your assumption holds: it was there before, and it’s there
now,<br />
so it must have been there in between.</p>
<p>This simple act of inference is something we do all the time. We fill
in gaps,<br />
assume continuity, and reason about what must have been present based on
what<br />
we know from partial glimpses of the world.</p>
<p>The presence calculus gives formal shape to this kind of
inference—and shows<br />
how we can build upon it to <em>reason</em> about presence and
<em>measure</em> its<br />
effects in an environment.</p>
<h2 id="a-software-example">A software example</h2>
<p>Since the ideas here emerged from the software world, let’s begin
with a<br />
mundane, but familiar example: task work in a software team.</p>
<p>By looking closely at how we reason about tasks, we can see how a
subtle shift<br />
to a presence-centered perspective changes not just what we observe, but
what<br />
we measure, and thus can reason about.</p>
<p>We usually reason about task work using <em>events</em> and
<em>snapshots</em> of the state<br />
of a process in time. A task “starts” when it enters development,
and<br />
“finishes” when it’s marked complete. We track “cycle time” by measuring
the<br />
elapsed time between events, “throughput” by counting finish events,
and<br />
“work-in-process” by counting tasks that have started but not yet
finished.</p>
<p>When we look at a Kanban board, we see a point-in-time snapshot of
where tasks<br />
are at that moment—but not how they got there. And by the time we read
a<br />
summary report of how many tasks were finished and how long they took to
go through the process on average, much of the history of the system
that produced those measurements has been lost. That makes it hard to
reason about <em>why</em> those measurements are the way they are.</p>
<p>In complex knowledge work, each task often has a distinct
history—different<br />
from other tasks present at the same time. Losing history makes it hard
to<br />
reason about their interactions and how they impact the global behavior
of the<br />
process.</p>
<p>This problem is not unique to task work. Similar problems exist in
almost all areas of business analysis that rely primarily on descriptive
statistics as the primary measurement tool for system behavior.</p>
<p>We are reduced to trying to make inferences from local
descriptive<br />
statistics —things like cycle times, throughput, and work-in-process
levels- over a rapidly changing process.</p>
<p>We try to reason about a process which is shaped by its history, with
measurement techniques that struggle to represent or reason about that
history. This is difficult to do, and we have no good tools right now
that are fit for<br />
this purpose.</p>
<p>This is where the presence calculus begins.</p>
<p>While it often starts from the same snapshots, the calculus focuses
on the<br />
time <em>in between</em>: when the task was present, where it was
present, for how<br />
long, and whether its presence shifted across people, tools, or
systems.</p>
<p>The connective tissue is no longer the task itself, or the process
steps it<br />
followed, or who was working on it, but a continuous, observable
<em>thread of<br />
presence</em>—through all of them, moving through time, interacting,
crossing boundaries—a mathematical representation of history.</p>
<p>With the presence calculus, these threads and their interactions
across time<br />
and space can now be measured, dissected, and analyzed as
first-class<br />
constructs—built on a remarkably simple primitive—the presence.</p>
<h2 id="the-heart-of-the-matter">The heart of the matter</h2>
<p>At its core, the calculus exploits the difference between the two
independent<br />
statements—“The task started development on Monday” and “The task
completed<br />
development on Friday”—and a single, unified assertion: “The task was
present<br />
in development from Monday through Friday.”</p>
<p>The latter is called a <em>presence</em>, and it is the foundational
building block<br />
of the calculus.</p>
<p>At first glance, this might not seem like a meaningful
difference.</p>
<p>But treating the presence as the primary object of reasoning—as a
<em>first-class</em> construct—opens up an entirely new space of
possibilities.</p>
<p>Specifically, it allows us to apply powerful mathematical tools that
exploit the continuity of time and the algebra of time intervals to
reason about the interactions and emergent configurations of presences
in a rigorous and structured, and more importantly, computable way.</p>
<h2 id="what-is-a-presence">What is a presence?</h2>
<p>Let’s start by building intuition for this concept we call a
<em>presence</em>.<br />
Consider the statement: “The task <span class="math inline">\(X\)</span>
was in Development from Monday to<br />
Friday.”</p>
<p>In the presence calculus, this would be expressed as a presence of
the form:<br />
“The element <span class="math inline">\(X\)</span> was in boundary
<span class="math inline">\(Y\)</span> from <span
class="math inline">\(t_0\)</span> to <span
class="math inline">\(t_1\)</span> with mass 1.”<br />
Presences are statements about elements (from some domain) being present
in a<br />
boundary (from a defined set of boundaries) over a <em>continuous</em>
period of time,<br />
measured using some timescale.</p>
<p>So why do we say “with mass 1”?</p>
<p>The presence calculus treats time as a physical dimension, much like
space.<br />
Just as matter occupies space, presences occupy time. Just as mass
quantifies<br />
<em>how</em> matter occupies space, the mass of a presence quantifies
<em>how</em> a<br />
presence occupies time.</p>
<p>The statement “The task <span class="math inline">\(X\)</span> was in
Development from Monday through Friday” is<br />
a <strong>binary presence</strong> with a uniform mass of 1 over the
entire duration. The<br />
units of this mass are element-time—in this case, task-days.</p>
<p>Binary presences are sufficient to describe the <em>fact</em> of
presence or absence<br />
of things in places in a domain. These presences always have mass 1 in
whatever units we use for elements and time.</p>
<h2 id="what-is-the-mass-of-a-presence">What is the mass of a
presence?</h2>
<p>Let’s consider a more detailed set of statements:</p>
<blockquote>
<p>“Task <span class="math inline">\(X\)</span> had 2 developers working
on it from Monday to Wednesday,<br />
3 developers on Thursday, and 1 developer on Friday.”</p>
</blockquote>
<p>These are no longer about just presence, but about the
<em>effects</em> of presence.<br />
They describe the <strong>load</strong> that task <span
class="math inline">\(X\)</span> placed on the Development
boundary<br />
over time.</p>
<p>The units of this presence are developer-days - potentially in a
completely different space from the task, but grounded over the same
time interval as the task.</p>
<p>Here we are saying: “the task being in this boundary over this time
period, had this effect.”</p>
<p>We will describe such presences using a <em>presence density
function,</em> called <span class="math inline">\(\mathsf{load}\)</span>
in this case:</p>
<ul>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Monday}, \text{Wednesday}, 2)\)</span></li>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Thursday}, \text{Thursday}, 3)\)</span></li>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Friday}, \text{Friday}, 1)\)</span></li>
</ul>
<p>Here, <span class="math inline">\(\mathsf{load}(e, b, t)\)</span> is
a time-varying function that takes an<br />
element <span class="math inline">\(e\)</span>, a boundary <span
class="math inline">\(b\)</span>, and a time <span
class="math inline">\(t\)</span>, and returns a real-valued number<br />
describing how much presence is concentrated at that point in time.</p>
<p>The <em>presence mass</em> of such a presence is the total presence
over the<br />
interval <span class="math inline">\([t_0, t_1]\)</span>, defined
as:</p>
<p><span class="math display">\[ \text{mass} = \int_{t_0}^{t_1}
\mathsf{load}(e, b, t)\, dt \]</span></p>
<p>where <span class="math inline">\(\mathsf{load}\)</span> is the
presence density function <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<h2
id="domain-signals-presence-density-functions-and-measure-theory">Domain
Signals, presence density functions and measure theory</h2>
<p>Binary presence functions are much easier to understand intuitively,
and we’ll<br />
continue using them in our examples. But the real power of the
presence<br />
calculus comes from generalizing to <em>presence density
functions</em>.</p>
<p>We may think of presence density functions as <em>domain signals</em>
that we are interesting in observing and measuring, and the presence
density functions can model a very large and general class of domain
signals, so in what follows we will often refer to presence density
functions as <em>signals</em> and use the two terms interchangeably.</p>
<p>In our earlier example, we interpreted the signal as<br />
expressing the <em>load</em> placed on an element at a boundary. But
more generally,<br />
a signal can be <em>any</em> real-valued function over time.</p>
<p>The mass of a presence, over any given time <em>interval</em> <span
class="math inline">\([t_0, t1)\)</span> is the integral above, which is
also the area under the signal over that interval<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/presence_definition.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 2: Signals, Presence,  and Presence Mass</code></pre>
</div>
</div>
<p>The only requirement for a function to be a presence density function
(signal) is that it is <em>measurable</em>, and that you can interpret
<em>presence mass</em>—defined as the integral of the function over a
finite interval—as a meaningful <em>measure</em> of the effect of
presence in your domain.</p>
<p>This is where measure theory enters the picture. It’s not essential
to<br />
understand the full technical details, but at its core, measure theory
tells<br />
us which kinds of functions are <em>measurable</em>—in other words,
which functions<br />
can support meaningful accumulation, comparison, and composition of
values.</p>
<p>Measurability gives us the confidence to do things like compute
statistics,<br />
aggregate over elements or boundaries, and compose presence
effects—while<br />
preserving the semantics of the domain. Informally, when a signal is
measurable, we can treat its values like any other real number and do
math over them, as long as we carefully respect the units involved.</p>
<p>From our perspective, a presence density function represents a signal
whose value that can be <em>accumulated</em> across time and across
presences. This<br />
lets us reason mathematically about presences with confidence—and since
most<br />
of this reasoning will be performed by algorithms, we need
technical<br />
constraints that ensure those calculations are both mathematically valid
and<br />
semantically sound.</p>
<p>To summarize:</p>
<p>A general presence is defined by:</p>
<ul>
<li>a density function <span class="math inline">\(f(e, b,
t)\)</span>,</li>
<li>an element <span class="math inline">\(e\)</span>,</li>
<li>a boundary <span class="math inline">\(b\)</span>,</li>
<li>and a time interval <span class="math inline">\([t_0,
t_1]\)</span>.</li>
</ul>
<p>Its <strong>mass</strong> is the integral of <span
class="math inline">\(f\)</span> over the interval:</p>
<p><span class="math display">\[ \text{mass}(e, b, [t_0, t_1]) =
\int_{t_0}^{t_1} f(e, b, t)\, dt \]</span></p>
<p>This mass captures both <em>that</em> the element was present, and
<em>how</em> it was<br />
present—uniformly, variably, or intermittently—over the time interval of
the presence.</p>
<h2 id="more-examples">More examples</h2>
<p>Let’s firm up our intuition about what presences can describe with a
few more<br />
examples.</p>
<h3 id="work-in-software">“Work” in software</h3>
<p>If you’ve ever written a line of code in your life, you’ve heard the
question:<br />
“When will it be done?” Work in software can be a slippery, fungible
concept—<br />
and the presence calculus offers a useful way to describe it.</p>
<p>We can express the work on a task using a presence density function
whose<br />
value at time <span class="math inline">\(t\)</span> is the
<em>remaining</em> work on the task at that moment.</p>
<p>This lets us model tasks whose duration is uncertain in general, but
whose<br />
remaining duration can be described at any given time—a common scenario
in<br />
software contexts.</p>
<p>A series of presences, where the (non-zero) mass of each presence
corresponds<br />
to the total remaining work over its interval (interpreting the integral
as a<br />
sum), gives us a way to represent <em>work as presence</em>.</p>
<p>Such presences can represent estimates, forecasts, or
confidence-weighted<br />
projections—and as we’ll see shortly, they can be reasoned about and
computed<br />
with just like any other kind of presence.</p>
<h3 id="the-effects-of-interruptions">The effects of interruptions</h3>
<p>Another useful example from the software world illustrates a
different<br />
application of a presence. Let’s assume the boundary in this case is
a<br />
developer, the element is an interruption (defined appropriately in
the<br />
domain), and the presence density function captures the <em>context
switching<br />
cost</em>—measured in lost time—associated with that interruption.</p>
<p>The key insight here is that the <em>effects</em> of the presence
extend beyond the<br />
interval of the interruption itself. This is a classic case of a delayed
or<br />
<em>decaying effect</em>—a pattern that appears frequently in real-world
systems.</p>
<p>The presence density function can be modeled in different ways:</p>
<ul>
<li>As a constant cost: for example, each interruption causes a
fixed<br />
15-minute recovery period, regardless of its duration.</li>
<li>As a decaying function: the cost is highest at the moment of
interruption<br />
and gradually decreases to zero over a defined recovery window
(e.g.<br />
15 minutes), representing a return to full focus.</li>
</ul>
<p>This approach gives us a precise way to model and reason about
the<br />
<em>aftereffects</em> of events—effects that outlast the events
themselves and<br />
accumulate in subtle but measurable ways over longer timeframes.</p>
<p>In this case, we measured an effect that decayed from a peak, but a
similar<br />
approach can be taken, for example, with a presence density function
that<br />
grows from zero and plateaus over the duration of the presence—such as
the net<br />
increase in revenue due to a released feature.</p>
<p>Used this way, presence density functions give us a powerful tool for
modeling<br />
the impact of binary presences—capturing their downstream or
distributed<br />
effects over time, and reasoning about their relationship over a
shared<br />
timeline.</p>
<p>Another important use case in the same vein is modeling the cost of
delay for a portfolio-level element—and analyzing its cascading impact
across the<br />
portfolio.</p>
<p>These use cases show that it is possible to analyze not just binary
presences,<br />
but entire chains of influence they exert across a timeline—a key
prerequisite<br />
for reasoning about causality.</p>
<h3 id="self-reported-developer-productivity">Self-reported developer
productivity</h3>
<p>Imagine a developer filling out a simple daily check-in:<br />
“How productive did you feel today?”—scored from 1 to 5, or sketched out
as a<br />
rough curve over the day<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<p>Over a week, this forms a presence density function—not of the
developer in a<br />
place, but of their <em>sense</em> of productivity over time.</p>
<p>These types of presences, representing perceptions, are
powerful—helping<br />
teams track experience, spot early signs of burnout, or correlate
perceived<br />
flow with meetings, environment changes, build failures, or
interruptions.</p>
<p>Now, let’s look at some examples outside software development.</p>
<h3 id="browsing-behavior-on-an-e-commerce-site">Browsing behavior on an
e-commerce site</h3>
<p>Imagine a shopper visiting an online store. They spend 90 seconds
browsing<br />
kitchen gadgets, then linger for five full minutes comparing
high-end<br />
headphones, before briefly glancing at a discounted blender.</p>
<p>Each of these interactions can be modeled as a presence: the
shopper’s<br />
(element) attention occupying different parts of the site (boundaries)
over<br />
time. The varying durations reflect interest, and the shifting presence
reveals<br />
patterns of engagement.</p>
<p>By analyzing these presences—where and for how long attention
dwells—we can<br />
begin to understand preferences, intent, and even the likelihood of
conversion<br />
(modeled as a different presence density function).</p>
<h3 id="patient-movement-in-a-hospital">Patient movement in a
hospital</h3>
<p>Consider a patient navigating a hospital stay. They spend the morning
in<br />
radiology, move to a recovery ward for several hours, then are
briefly<br />
transferred to the ICU overnight.</p>
<p>Each location records a presence—when and where the patient was, and
for how<br />
long. These presences can reveal bottlenecks, resource utilization,
and<br />
potential risks.</p>
<p>Over time, analyzing patient presences helps surface patterns in
care<br />
delivery, delays in treatment, and opportunities for improving patient
flow.</p>
<p>These are examples of classic operations management problems
expressed in the<br />
language of the presence calculus. The calculus is well-suited to
modeling<br />
scenarios like these as a base case.</p>
<h2 id="systems-of-presences">Systems of Presences</h2>
<p>Let’s summarize what we’ve described so far.</p>
<p>With signals and presences, we now have a general structure<br />
for describing and measuring the behaviour of an arbitrary time varying
function. The key feature of a presence is that it abstracts these
behaviors into a uniform representation—one that we can reason about and
compute with.</p>
<h3 id="presence-assertions">Presence Assertions</h3>
<p>In Figure 2, we showed the <em>onset</em> and <em>reset</em> times of
a presence density<br />
function. The interval between an onset and a reset is called the
<em>support</em> of<br />
the signal. Within this interval, the function is non-zero.</p>
<p>As we see in Figure 3, a given signal may have <em>multiple</em> such
disjoint support<br />
intervals. These represent non-contigous presences of the same element
within the same boundary over time. These may correspond, to episodic
behavior in the underlying domain, for example, user sessions in an
e-commerce context, or rework loops in software development when a task
“returns” to development many times over its lifecycle.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/multiple_support.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 3: A presence as a sample of a signal over an interval.</code></pre>
</div>
</div>
<p>A presence may be defined over <em>any</em> sub-interval of a signal,
as shown in Figure 3.</p>
<p>There are many possible ways of defining a presence from a signal,
including across disjoint support intervals. All we require is that the
interval in question intersects a region of non-zero area that can be
reduced to a presence mass.</p>
<p>So, a presence is best thought of as a <em>sampled measurement</em>
of the underlying<br />
signal, taken by an <em>observer</em> over two specific points in time
and reduced to a point-mass measurement over that interval.</p>
<p>A given observer may not even “see” the full underlying signal—only
the <em>mass</em><br />
of the presence they experience over the interval they observed.</p>
<p>Different observers may observe different intervals of the same
signal and derive different presence values, depending on what part of
the function they<br />
encounter.</p>
<p>This brings us to the concept of <em>presence assertions</em>, which
formalize this<br />
idea of an observer recording a presence based on their local view of
the<br />
underlying density function.</p>
<p>A <em>presence assertion</em> is simply a presence augmented with
metadata:</p>
<ul>
<li><em>who</em> the observer was</li>
<li>and an <em>assertion timestamp</em>—the time at which the
observation was made.</li>
</ul>
<p>The assertion time doesn’t need to align with the time interval of
the presence. This allows assertions to refer to the past, reflect the
present, or even anticipate the future behavior of a signal.</p>
<p>Presence assertions give us the ability to assign <em>provenance</em>
to a presence—<br />
not just <em>what</em> we know, but <em>how</em> we know it. This is
essential in<br />
representing complex systems where the observer and the act of
observation<br />
are first-class concerns.</p>
<p>We won’t go too deeply into the epistemological aspects of the
presence<br />
calculus here—this remains an active and open area of research.</p>
<p>But it’s important to acknowledge that this layer exists, that
modeling and interpreting the output of the presence calculus requires
an explicit treatment of how observations are made and by whom, and the
fact that this has a huge impact on the validity of the inferences one
makes using the machinery of the calculus.</p>
<p>With this caveat in place, once we’ve represented a problem domain as
a<br />
<em>system of presences</em>, much of the machinery of the presence
calculus (which<br />
we’ll introduce next) can be applied uniformly.</p>
<p>For the next couple of sections, where we will introduce this
machinery, we will operate under the assumption that there is a
<em>signal</em> that can be observed and what we observe about the
signal reflects what an observer knows about the domain. We don’t
presume anything about the “truth” of the observations, we treat them
uniformly as signals.</p>
<p>One thing we will see is that from the perspective of this machinery,
there are no fundamental differences in behavior between binary signals
and arbitrary signals once they’ve been reduced to a canonical,
presence-mass oriented representation<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>This greatly increases the scope of the problem domains where this
machinery can be applied, and our examples in the previous section began
to hint at the possibilities.</p>
<p>This, in the end, is the source of the generality and power of the
presence calculus.</p>
<h2 id="co-presence-and-the-presence-invariant">Co-Presence and The
Presence Invariant</h2>
<p>In the last section, we introduced <em>systems of presences</em> as
collections of presence assertions defined over a set of presence
density functions (signals).</p>
<p>Figure 5 illustrates an example of such a system, where we focus on
the subset of presences defined over a <em>shared observation
interval</em>.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/presence_invariant_continuous.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 5: The Presence Invariant</code></pre>
</div>
</div>
<p>These presences are called <em>co-present</em>—they represent an
observer making simultaneous measurements of presence mass across
multiple signals over a common interval of time.</p>
<p>Co-presence is a necessary (but not sufficient) condition for
interaction between one or more signals. In this section, we introduce a
key construct in the presence calculus: the <em>presence invariant</em>.
It expresses a general and powerful relationship that holds for any
co-present subset of presences within a finite observation window. and
is a fundamental relationship tha governs how the masses of co-present
signal’s interact.</p>
<p>Let’s establish this relationship.</p>
<p>Given, any finite observation interval, we’ve already shown that each
presence density function has a <em>presence mass</em>, defined as the
integral of the density over the observation interval.</p>
<p>These can be thought of These can be thought of as mass contributions
from those presences to that interval. The sum of these individual
<em>mass contributions</em> gives the total presence mass observed
across the system in that interval.</p>
<p>Let</p>
<p><span class="math display">\[ A = M_0 + M_1 + M_3 \]</span></p>
<p>be the total mass contribution from the signals that have non-zero
mass over the interval <span class="math inline">\([t_0, t_1)\)</span>.
The length of this interval is <span class="math inline">\(T = t_1 -
t_0\)</span>.</p>
<p>Since the mass comes from integrating a density function over time,
the quantity <span class="math inline">\(\frac{A}{T}\)</span> represents
the <em>average presence density</em> over the observation interval. We
can now decompose this as:</p>
<p><span class="math display">\[ \delta = \frac{A}{T} = \frac{A}{N}
\times \frac{N}{T} \]</span></p>
<p>This separates the average presence density into two interpretable
components:</p>
<ul>
<li><span class="math inline">\(\bar{m} = \frac{A}{N}\)</span>: the
<em>average mass contribution</em> per active signal,</li>
<li><span class="math inline">\(\iota = \frac{N}{T}\)</span>: the
<em>incidence rate</em>—i.e., the number of active signals per unit
time.</li>
</ul>
<p>This leads to the <em>presence invariant</em>:</p>
<p><span class="math display">\[ \text{Average Presence Density} =
\text{Incidence Rate} \times \text{Average
Mass Contribution} \]</span> or in our notation</p>
<p><span class="math display">\[ \delta = \iota \cdot \bar{m}
\]</span></p>
<p>This identity holds for <em>any</em> co-present subset of signals
over <em>any</em> finite time interval.</p>
<p>While algebraically, this relationship is a tautology, it imposes a
powerful constraint on system behavior—one that is independent of the
specific system, semantics, or timescale.</p>
<p>Indeed, it forms a foundational conservation law of the presence
calculus: the <em>conservation of mass (contributions)</em>.</p>
<p>Just as the conservation of energy or mass constrains the evolution
of physical systems—regardless of the specific materials or forces
involved—the conservation of presence mass constrains how observable
activity is distributed over time in a system of presences.</p>
<p>It is independent of the semantics of what is being observed: like
energy, presence mass can shift, accumulate, or redistribute, but it
remains balanced when distributed across presences over a finite
interval remains invariant.</p>
<p>Thus, the conservation of mass plays a role in the presence calculus
similar to that of other conservation laws in physics. It constrains the
behavior of three key observable, measurable parameters of any system of
presences.</p>
<p>More importantly, exploiting this constraint allows us to study and
characterize the long-run behavior of the system.</p>
<p>This provides a rigorous framework for reasoning about the history of
a path-dependent system of presences—a key prerequisite for analyzing
the long-run evolution of presence systems and understanding emergent
patterns in that evolution.</p>
<h3 id="the-presence-invariant-for-binary-presences">The Presence
Invariant for Binary Presences</h3>
<p>One of the key features of the presence calculus is that it provides
very general mechanisms for computing over functions—but the value of
this machinery is only realized through modeling and reinterpreting its
results in the language of the domain.</p>
<p>At this stage, the presence invariant may still feel rather abstract.
Let’s make it more concrete by interpreting this identity in the special
case of <em>binary</em> presences.</p>
<p>Recall that a <em>binary</em> signal is a function whose density is
either <span class="math inline">\(0\)</span> or <span
class="math inline">\(1\)</span>. That is, we are modeling the presence
or absence of an underlying signal in the domain.</p>
<p>In this case, the <em>mass contribution</em> of a signal becomes an
element-time duration. For example, if the signal represents the time
during which a task is present in development, the mass contribution of
that task over an observation interval is the portion of its duration
that intersects the interval. This is also called the <em>residence
time</em> for the task in the observation window.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/presence_invariant_binary.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 6: The Presence Invariant for binary signals</code></pre>
</div>
</div>
<p>Figure 6 shows possible configurations of binary signals intersecting
a finite observation interval.</p>
<p>Suppose the unit of time is days.</p>
<p>The total presence mass accumulation <span
class="math inline">\(A\)</span> is <span
class="math inline">\(11\)</span> task-days. The number <span
class="math inline">\(N\)</span> of tasks that intersect the observation
interval is <span class="math inline">\(4\)</span>. The length of the
observation window is <span class="math inline">\(T = 4\)</span> days.
It is straightforward to verify that the presence invariant holds.</p>
<p>Now, let’s unpack its meaning.</p>
<p>Since each task contributes <span class="math inline">\(1\)</span>
unit of mass for each unit of time it is present, the average presence
density $ = $ represents the <em>average number of tasks</em> present
per unit time in the interval—denoted <span
class="math inline">\(L\)</span>.</p>
<p>Conversely, since each unit of mass corresponds to a unit of time
associated with a task, the average mass per active presence, <span
class="math inline">\(\bar{m} = \frac{A}{N}\)</span>, is the average
time a task spends in the observation window. This value is typically
called the <em>residence time</em> <span
class="math inline">\(w\)</span> of a task in the observation window, a
term we will adopt in general for presences.</p>
<p>The incidence rate <span class="math inline">\(\iota =
\frac{N}{T}\)</span> may be interpreted as the <em>activation rate</em>
of tasks in the interval—a proxy for the rate at which tasks start
(onset) or finish (reset) within the window.</p>
<p>For example, <span class="math inline">\(N\)</span> may be counted as
the number of tasks that start inside the interval, plus the number that
started before but are still active. Thus, <span
class="math inline">\(\frac{N}{T}\)</span> approximates a <em>cumulative
onset rate</em> <span class="math inline">\(\Lambda\)</span>.</p>
<p>The presence invariant can now be rewritten as:</p>
<p><span class="math display">\[ L = \Lambda \times w \]</span></p>
<p>which you may recognize as <em>Little’s Law</em> applied over a
finite observation window. Thus, the presence invariant serves as a
<strong>generalization of Little’s Law</strong>—extending it to
arbitrary systems of presence density functions (signals).</p>
<p>We’ll also note that for any arbitrary signal, we can always define a
binary presence corresponding to the intervals over which the value of
the density function is non-zero (the support interval) and so in
general, we can say the finite window version of Little’s Law, with the
above definitions, always applies to <em>any</em> signal, <em>in
addition</em> to the general presence invariant, which applies to the
full signal, not just its support.</p>
<p>It is important to note that we are referring to <em>Little’s Law
over a finite observation window</em>, rather than the much more
familiar, steady-state equilibrium form of Little’s Law.</p>
<p>Just like the presence invariant in the general case, this version of
the law holds <em>unconditionally</em>. The key is that the quantities
involved are <em>observer-relative</em>: the time tasks spend <em>within
the observation window</em>, and the <em>activation rate</em> of tasks
<em>over the window</em>, rather than the task-relative durations or
steady-state arrival/departure rates used in classical queueing
theory.</p>
<p>Indeed, in the general case, the difference between these two forms
of the identity will serve as the basis for how we <em>define</em>
whether a system of presences is in equilibrium or not. The idea is that
the system of presences is at equilibrium when observed over
sufficiently long observation windows such that the observer-relative
and task-relative values of average presence density, incidence rate and
average presence mass converge.</p>
<p>Since complex systems often operate far from equilibrium—and since
the presence invariant holds <em>regardless</em> of equilibrium—the
finite-window form becomes far more valuable for analyzing the long-run
behavior of such systems as they <em>move into and between</em>
equilibrium states.</p>
<p>We will return to this important topic shortly. But first, let’s
build a bit more machinery so that we can work computationally with
systems of presences in a more natural and systematic way.</p>
<h2 id="the-presence-invariant-and-causal-reasoning">The Presence
Invariant and Causal Reasoning</h2>
<p>The presence invariant gave us an important constraint that applies
to the behavior of three key parameters of a system of presences when
measured over any finite time interval: the average presence density,
the incidence rate, and the average mass contribution per presence.</p>
<p>This means that if we observe the behavior of a system of presences
over a continuous sequence of non-overlapping time intervals, the
presence invariant holds in <em>each</em> such interval, and given the
value of any two of the parameters, the third is completely
determined.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/system_presences_discrete.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 7: Sampling a system of presence across uniform intervals. </code></pre>
</div>
</div>
<p>The requirement that presence mass is conserved across each interval
means that there are only two degrees of freedom in how the three
variables can change.</p>
<p>This implies that if we study how these parameters change in concert
as we move <em>across</em> time intervals, we will get unique insights
into how a <em>particular</em> system of presences evolves over
time.</p>
<p>If, for example, we know that the average presence density has
increased between one interval and the next, then we know for sure that
either the incidence rate, or average mass per presence (or both) have
increased.</p>
<p>Moreover, these are the <em>only</em> possible explanations for the
increase in the average presence mass. Any other explanation must also
lead to the changes in one of the two primary drivers of the average
presence density.</p>
<p>This is a powerful tool in being able to analyze <em>why</em> a
system of presences behaves the way it does and this is a fundamental
benefit of having a tool like the presence invariant at our
disposal.</p>
<p>Specifically, if we think of these three parameters of a system as
defining the unique co-ordinates of the state of the system over a small
finite interval, we can “trace” the movement of the system by following
these co-ordinates. But since there are only two degrees of freedom
these coordinates will always lie on a two dimensional surface, called a
manifold in a 3 dimensional space.</p>
<p>If fact, remarkably, the state of every possible system of presences,
no matter how general, always has a trajectory in time that lies on this
<em>same</em> manifold.</p>
<p>This is a powerful constraint and insight that we can use to study
the behavior of complex systems, and in order to make this easier to
calculate we will introduce a tool called the presence matrix that makes
it easier to keep track of the computations involved in doing this.</p>
<h2 id="the-presence-matrix">The Presence Matrix</h2>
<p>A <em>presence matrix</em> captures this structure by sampling a set
of presence density functions over a fixed set of time intervals.
Specifically, if we fix a time granularity—such as hours or days—we can
construct a matrix in which:</p>
<ul>
<li><p><em>Rows</em> correspond to individual signals (e.g., for each
<span class="math inline">\((
e, b)\)</span> pair),</p></li>
<li><p><em>Columns</em> correspond to non-overlapping time intervals
<em>that cover the time axis</em>,</p></li>
<li><p><em>Entries</em> contain the <em>presence mass</em>, i.e., the
integral of the density function over the corresponding interval:</p>
<p><span class="math display">\[ M_{(e,b),j} = \int_{t_j}^{t_{j+1}}
f_{(e,b)}(t) \, dt \]</span></p></li>
</ul>
<p>The resulting matrix provides a discrete, temporally-aligned
representation of this system of presences. Since we are accumulating
presence masses over an interval, the value of presence mass in a matrix
entry is always a a real number.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pandoc/presence_matrix.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 8: Presence Matrix for a system of presences. </code></pre>
</div>
</div>
<p>We wont spend too much more time on the presence matrix in this
document, except to note that it is a general and useful data structure
to efficiently represent and measure long run behavior of systems of
presence derived from real world signals.</p>
<p>The Presence Calculus Toolkit has more details on the mechanics of
its construction and how it is used to compute the parameters in the
presence invariant efficiently for general systems of presence.</p>
<h2 id="interpreting-the-presence-invariant">Interpreting the Presence
Invariant</h2>
<p>The presence calculus might seem like a highly abstract, theoretical
framework, but much of its utility emerges when we <em>interpret</em>
its concepts in a specific, applied context.</p>
<p>Concepts such as presence mass, incidence rates, and density are not
unlike abstract physical notions like force, mass, and acceleration. In
principle, these are measurable quantities that nature constrains to
behave in prescribed ways at a micro scale.</p>
<p>Once we understand the rules governing their micro-scale behavior, we
gain tools to systematically measure, reason about, and explain a vast
range of observable macro-scale phenomena. Much of physics is built on
this principle.</p>
<p>In a similar vein, the presence calculus—and especially the
<em>presence invariant</em> —provides a foundational law that governs
the local, time-based behavior of any system composed of time-varying
signals and the presences they induce.</p>
<p>Once we recognize that such a governing constraint exists, the
presence calculus equips us with tools to describe, interpret, explain,
and, in certain cases,<br />
make verifiable predictions about the macro-scale behavior of these
systems.</p>
<p>Newtonian mechanics, for example, allows us to describe and predict
the motion of physical systems with remarkable precision—such as
planetary orbits or the paths of falling objects. Yet even within this
well-established framework, certain limits remain: the general
three-body problem has no closed-form solution, and systems like the
double pendulum exhibit chaotic behavior that defies long-term
prediction.</p>
<p>Still, we can represent such systems as deterministic trajectories
through a parameter space, uncovering structure even where precise
global behavior remain unpredictable. In much the same way, the presence
calculus does not seek to forecast the exact evolution of complex
systems. Instead, by explicitly modeling signal histories and
representing element trajectories over time, it equips us with powerful
descriptive and explanatory tools.</p>
<p>These structural constraints and local invariants help us interpret
observed dynamics and, in certain cases, make verifiable predictions of
system behavior at the macro scale.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This document is the first step in that direction. We
welcome feedback on how it can be improved,and the concepts clarified.
Please feel free to open a pull request with thoughts, suggestions or
feedback.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>If integration signs in a “gentle” introduction feels
like a bait-and-switch, rest assured, this is the last time you will
need to think of them in this document - <em>provided</em> you accept
the statement that anything that we can do it in presences calculus with
binary presences can also be done with general presence density
functions. Besides, we had to say something about why we call this a
<em>calculus</em>, and this is as good a point to do that as any!<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The way we’ve defined signals and mass is directly<br />
analogous to how mass is defined for matter occupying space in
physics.</p>
<p>A binary signal can be thought of as defining a one-dimensional
interval over<br />
time. For a fixed element and boundary, this gives us an area under
the<br />
curve in two dimensions: time vs. density.</p>
<p>If we treat elements and boundaries as additional independent
dimensions,<br />
then the signal defines a <em>volume</em> in three dimensions, with time
as one axis.</p>
<p>This interpretation—presence as a physical manifestation of density
over<br />
time—is a powerful way to reason intuitively and computationally about
duration, overlap, and accumulation in time.</p>
<p>And when we allow multiple signals to interact over the same time
periods, we<br />
begin to model complex, higher-dimensional effects of presence—exactly
the<br />
kind of generality we’ll need when we move beyond simple binary
presences.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The use of a rough curve here is an example of how
presences can encode<br />
continuous inputs more effectively than discrete techniques, thanks to
their<br />
explicit model of time. Forcing a developer to rank their productivity
on a<br />
Likert scale often loses valuable nuance—whereas a fine-grained
presence<br />
captures temporal variation with ease, making it available for
downstream<br />
analysis.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>There are several technical conditions that must be
satisfied when<br />
mapping signals to a canonical system of presences in order for this
claim to<br />
hold. To avoid getting bogged down in those details, we’ll simply claim
it for<br />
now. The API docs go into more detail about the mechanics of this
canonical<br />
representation, and what’s needed to ensure a “clean” mapping from a
signal to a system of presences—or more precisely, a system of presence
assertions.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
