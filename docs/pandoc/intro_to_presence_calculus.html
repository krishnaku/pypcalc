<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>intro_to_presence_calculus</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
</head>
<body>
<h1 id="the-presence-calculus-a-gentle-introduction">The Presence
Calculus, <br> A Gentle Introduction</h1>
<p><strong>Dr. Krishna Kumar</strong><br />
<em>The Polaris Advisor Program</em></p>
<h2 id="what-is-the-presence-calculus">What is The Presence
Calculus?</h2>
<p>The Presence Calculus is a new approach for reasoning quantitatively
about the<br />
relationship between things and places in a domain over time.</p>
<p>The primary goal is to support rigorous modeling and principled<br />
decision-making with business-oriented data in complex, real-world
domains,<br />
while ensuring that the use of data in such decisions rests on a<br />
mathematically precise, logically coherent, and epistemically
grounded<br />
foundation.</p>
<p>The presence calculus emerged from a search for better quantitative
tools to<br />
reason about software product development and engineering, where
current<br />
approaches leave much to be desired in all three aspects.</p>
<p>The foundational constructs of the calculus give mathematical
precision to<br />
informally expressed ideas such as flow, stability, equilibrium,
and<br />
coherence. But more importantly, it allows us to relate them to
practically<br />
useful measures like delay, cost, revenue, and user experience.</p>
<p>And, as you’ll see, the ideas behind the calculus are far more
general, with<br />
applications well beyond this domain.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pcalc/presence_calculus.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 1: Key constructs—presences, element trajectories, presence matrix,  
and basis topology</code></pre>
</div>
</div>
<h1 id="the-pitch">The pitch</h1>
<p>We introduce a simple but powerful concept of a <em>presence</em>—one
that helps<br />
connect descriptive statistics, statistical inference, and
probabilistic<br />
reasoning to more powerful techniques from measure theory, topology,
and<br />
complex analysis.</p>
<p>The key thing this gives us is a formal model to reason explicitly
about time,<br />
history, and evolution in a domain. Classical statistics and
probability<br />
theory often struggle here.</p>
<p>In domains where understanding <em>history</em>—the sequence and
structure of changes<br />
in the domain over time—is essential, they collapse under assumptions
like<br />
ergodicity, stationarity, and independence.</p>
<p>However, they are very powerful tools for describing local
behavior,<br />
identifying patterns and correlations in this behavior, and
modeling<br />
uncertainty—all crucial prerequisites for any meaningful analysis of
complex<br />
systems.</p>
<p>But we need to be able to treat history and interdependence as
first-class<br />
concepts we can reason about, if we want to move beyond local behavior
and<br />
start modeling and reasoning about the long-run behavior of complex
systems.</p>
<p>The presence calculus gives us a constructive approach to bridging
this gap.</p>
<p>It helps us move from statistical and probabilistic models to
more<br />
specialized—but more powerful—analysis tools from disciplines such
as<br />
stochastic process dynamics, queueing theory, and complex systems
science—<br />
starting from an explicit domain model.</p>
<p>This is a bold claim—and deserves careful scrutiny and validation.
Our goal in<br />
this document is to make the ideas accessible enough for more people
to<br />
pressure test this claim.</p>
<p>While the calculus was developed with mathematical rigor, an equally
important<br />
goal was not to let mathematics get in the way of understanding the
rather<br />
simple but very powerful and general ideas the calculus embodies.</p>
<p>We believe the presence calculus is a fundamental and powerful
reasoning tool<br />
for anyone working with complex systems, and invite anyone interested
in<br />
developing and pressure-testing the ideas here further to collaborate on
this<br />
as an open source project.</p>
<h2 id="learning-more-about-the-presence-calculus">Learning more about
The Presence Calculus</h2>
<p>In this document, we’ll motivate and introduce the key ideas in the
calculus<br />
informally, with lots of highly simplified examples and allusions
to<br />
illustrate concepts. It is aimed squarely at the non-technical
reader.</p>
<p>We recommend reading and understanding the ideas here before jumping
deeper<br />
into the rest of the documentation at this site, which does get a fair
bit<br />
more dense. We’ll also continue with ongoing informal exposition on our
blog<br />
<a href="https://www.polaris-flow-dispatch.com">The Polaris Flow
Dispatch</a>.</p>
<p>The next level of detail is in the API docs for the <a
href="https://py.pcalc.org">The Presence Calculus<br />
Toolkit</a>. Here we go into the concepts at a level of<br />
rigor that you’ll need to work with the pcalc API and build tools using
the<br />
concepts. Some mathematical background will be useful here if you want
to<br />
work on the core.</p>
<p>Finally, for those who want to dive deeper into the formal
mathematical<br />
underpinnings of the calculus, we have the theory track, which perhaps
goes<br />
into more detail than most people will need to read or understand, but
is<br />
useful for the mathematically trained to connect the ideas to their
roots in<br />
mainstream mathematics.</p>
<p>Let’s jump in…</p>
<h2 id="why-presence">Why Presence?</h2>
<p>Presence is how reality reveals itself. We do not perceive the
world<br />
as disjointed events in time, but rather, as an unfolding—things<br />
come into being, endure for a time, and slip away.</p>
<p>Permanence is just a form of lasting presence, and what we call<br />
change is the movement of presences in and out of our awareness, often
set<br />
against this permanence.</p>
<p>The sense of something being present, or no longer present, is our
most<br />
immediate way of detecting change. This applies to both the tangible and
the<br />
intangible.</p>
<p>Either way, we reason about the world around us by reasoning
about<br />
the presences and absences in our environment over time.</p>
<p>The presence calculus begins here. Before counting, measuring,
comparing, or<br />
optimizing, we observe what <em>is</em>.</p>
<p>And what we model is presence.</p>
<h1 id="an-example">An example</h1>
<p>Imagine you see a dollar bill on the sidewalk on your way to get
coffee.<br />
Later, on your way back home, you see it again—still lying in the same
spot.<br />
It would be reasonable for you to assume that the dollar bill was
present<br />
there the whole time.</p>
<p>Of course, that may not be true. Someone might have picked it up in
the<br />
meantime, felt guilty, and quietly returned it. But in the absence of
other<br />
information, your assumption holds: it was there before, and it’s there
now,<br />
so it must have been there in between.</p>
<p>This simple act of inference is something we do all the time. We fill
in gaps,<br />
assume continuity, and reason about what must have been present based on
what<br />
we know from partial glimpses of the world.</p>
<p>The presence calculus gives formal shape to this kind of
inference—and shows<br />
how we can build upon it to <em>reason</em> about presence and
<em>measure</em> its<br />
effects in an environment.</p>
<h1 id="a-software-example">A software example</h1>
<p>Since the ideas here emerged from the<br />
software world, let’s begin with a familiar example: task work in a
software<br />
team.</p>
<p>By looking closely at how we reason about tasks, we can see how a
subtle shift<br />
to a presence-centered perspective changes not just what we observe, but
what<br />
we measure, and thus can reason about.</p>
<p>We usually reason about task work using <em>events</em> and
<em>snapshots</em> of the state<br />
of a workflow in time. A task “starts” when it enters development,
and<br />
“finishes” when it’s marked complete. We track “cycle time” by measuring
the<br />
elapsed time between events, “throughput” by counting finish events,
and<br />
“work-in-process” by counting tasks that have started but not yet
finished.</p>
<p>When we look at a Kanban board, we see a point-in-time snapshot of
where tasks<br />
are at that moment—but not how they got there. And by the time we read
a<br />
summary report of how many tasks were finished and how long they took
on<br />
average, much of the history of the system that produced those outcomes
has<br />
been lost. That makes it hard to reason about <em>why</em> those
measurements are the<br />
way they are.</p>
<p>In complex knowledge work, each task often has a distinct
history—different<br />
from other co-temporaneous tasks. Losing history makes it hard to<br />
reason about the global behavior of the process.</p>
<p>We are reduced to trying to make inferences from local descriptive
statistics of a rapidly changing system. We try to reason about this
system, which is shaped by its history, without a way to represent or
reason about that history. This is difficult to do, and we have no tools
that are fit for this purpose.</p>
<p>This is where the presence calculus begins. While it often starts
from the<br />
same snapshots, the calculus focuses on the time <em>in between</em>:
when the task<br />
was present, where it was present, for how long, and whether its
presence<br />
shifted across people, tools, or systems.</p>
<p>The connective tissue is no longer the task itself, or the steps it
followed,<br />
or who was working on it, but a continuous, observable <em>thread of
presence</em>—<br />
through all of them, moving through time, crossing boundaries—a
mathematical<br />
representation of history.</p>
<p>With the presence calculus, these threads and their interactions
across time<br />
and space can now be measured, dissected, and analyzed as
first-class<br />
constructs—built on a remarkably simple primitive—the presence.</p>
<h1 id="the-heart-of-the-matter">The heart of the matter</h1>
<p>The calculus, at its core, comes down to the difference between the
two<br />
independent statements—“The task started development on Monday” and “The
task<br />
completed development on Friday”—and a single, unified assertion: “The
task<br />
was present in development from Monday through Friday.”</p>
<p>The latter is called a <em>presence</em>, and it is the foundational
building block of the<br />
calculus.</p>
<p>At first glance, this might not seem like a meaningful
difference.</p>
<p>But treating the presence as the primary object of reasoning—as a
<em>first-class</em><br />
construct—opens up an entirely new space of possibilities, because it
allows<br />
us to apply powerful mathematical tools that exploit the continuity in
time<br />
and the algebra of time intervals to reason about complex assemblages of
presences in a rigorous and structured, and more importantly, computable
way.</p>
<p>Let’s see how.</p>
</body>
</html>
