<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>intro_to_presence_calculus</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
</head>
<body>
<h1 id="the-presence-calculus-a-gentle-introduction">The Presence
Calculus, <br> A Gentle Introduction</h1>
<p><strong>Dr. Krishna Kumar</strong><br />
<em>The Polaris Advisor Program</em></p>
<h2 id="what-is-the-presence-calculus">What is The Presence
Calculus?</h2>
<p>The Presence Calculus is a new approach for reasoning quantitatively
about the relationship<br />
between things and places over time.</p>
<p>The primary goal is to support rigorous modeling and principled<br />
decision-making with operational data in complex, real-world domains,
while ensuring<br />
that the use of data in such decisions rests on a mathematically<br />
precise, logically coherent, and epistemically grounded foundation.</p>
<p>The presence calculus emerged from a search for better tools to<br />
reason about operations management in software development, where
current<br />
approaches to quantitative reasoning leave much to be desired in all
three<br />
aspects.</p>
<p>Here, the foundational constructs of the calculus give mathematical
precision to informally expressed ideas such as flow, stability,
equilibrium, and coherence. But more importantly, it allows us to relate
them to<br />
practically useful measures like delay, cost, revenue, and user
experience.</p>
<p>But as you’ll see, the ideas behind the calculus are far more
general, with applications<br />
well beyond software.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pcalc/presence_calculus.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 1: Key constructs—presences, element trajectories, presence matrix,  
and basis topology</code></pre>
</div>
</div>
<p>When working with operational data, the presence calculus introduces
a simple but powerful<br />
concept of a <em>presence</em>—one that helps us move beyond the limited
powers of<br />
statistics and statistical inference, and apply far more powerful
techniques<br />
from measure theory, topology, and complex analysis to the modeling
and<br />
analysis of system behavior.</p>
<p>It gives us constructive tools to bridge statistical reasoning with
more<br />
specialized—but more powerful—approaches such as stochastic process
dynamics,<br />
queueing theory, and complex systems science, all from first principles
of a domain.</p>
<p>While the calculus was developed with mathematical rigor, an equally
important<br />
goal was not to let mathematics get in the way of understanding the
rather<br />
simple but very powerful and general ideas it embodies.</p>
<p>Our goal in this document is to make this formalism accessible enough
to build powerful<br />
applications on top of — not just for us, but as a new reasoning tool
for<br />
anyone working with complex systems.</p>
<h2 id="learning-more-about-the-presence-calculus">Learning more about
The Presence Calculus</h2>
<p>In this document, we’ll motivate and introduce the key ideas in the
calculus<br />
informally, with lots of highly simplified examples and allusions
to<br />
illustrate concepts. It is aimed squarely at the non-technical
reader.</p>
<p>We recommend reading and understanding the ideas here before jumping
deeper<br />
into rest of the documentation at this site which does get a fair bit
more<br />
dense. We’ll also continue with ongoing informal exposition on our
blog<br />
<a href="https://www.polaris-flow-dispatch.com">The Polaris Flow
Dispatch</a>.</p>
<p>The next level of detail is in the API docs for the <a
href="https://py.pcalc.org">The Presence Calculus<br />
Toolkit</a>. Here we go into the concepts at a level of<br />
rigor that you’ll need to work with the pcalc API and build tools using
the<br />
concepts. Some mathematical background will be useful here if you want
to<br />
work on the core.</p>
<p>Finally, for those who want to dive deeper into the formal
mathematical<br />
underpinnings of the calculus, we have the theory track which perhaps
goes<br />
into more detail than most people will likely need to read or
understand, but<br />
is useful for the mathematically trained to connect the ideas to its
roots in<br />
mainstream mathematics.</p>
<p>Lets jump in…</p>
<h2 id="why-presence">Why Presence?</h2>
<p>Presence is how reality reveals itself. We do not perceive the
world<br />
as disjointed events in time, but rather, as a continual
unfolding—things<br />
coming into being, enduring for a time, and slipping away.</p>
<p>Permanence is just a form of lasting presence, and what we call<br />
change is the movement of presences in and out of our awareness, often
set<br />
against this permanence.</p>
<p>The sense of something being present, or no longer present, is our
most<br />
immediate way of detecting change. This applies to both the tangible and
the<br />
intangible—either way, we reason about the world around us by reasoning
about<br />
the presences and absences in our environment over time.</p>
<p>The presence calculus begins here. Before counting, measuring,
comparing, or<br />
optimizing, we observe what <em>is</em>.</p>
<p>And what we observe and reason about, first and always, is
presence.</p>
<h1 id="an-example">An example</h1>
<p>Imagine you see a dollar bill on the sidewalk on your way to get
coffee.<br />
Later, on your way back home, you see it again—still lying in the same
spot.<br />
It would be reasonable for you to assume that the dollar bill was
present<br />
there the whole time.</p>
<p>Of course, that may not be true. Someone might have picked it up in
the<br />
meantime, felt guilty, and quietly returned it. But in the absence of
other<br />
information, your assumption holds: it was there before, and it’s there
now,<br />
so it must have been there in between.</p>
<p>This simple act of inference is something we do all the time. We fill
in gaps,<br />
assume continuity, and reason about what must have been present based on
what<br />
we know from partial glimpses of the world.</p>
<p>The presence calculus gives formal shape to this kind of
inference—and shows<br />
how we can build upon it to <em>reason</em> about presence and
<em>measure</em> its<br />
effects in an environment.</p>
<h1 id="a-software-example">A software example</h1>
<p>Since this work grew from the study of operations management problems
in the<br />
software world, let’s begin with a familiar example: task work in a
software<br />
team.</p>
<p>By looking closely at how we reason about tasks, we can see how a
subtle shift<br />
to a presence-centered perspective changes not just what we observe, but
what<br />
we measure, and thus can reason about.</p>
<p>We often reason about task work using <em>events</em> and
<em>snapshots</em> of the state<br />
of a workflow in time. A task “starts” when it enters development,
and<br />
“finishes” when it’s marked complete. We track “cycle time” by measuring
the<br />
elapsed time between events, “throughput” by counting finish events,
and<br />
“work-in-process” by counting tasks that have started but not yet
finished.</p>
<p>When we look at a Kanban board, we see a point-in-time snapshot of
where tasks<br />
are at that moment—but not how they got there. And by the time we read
a<br />
summary report of how many tasks were finished and how long they took
on<br />
average, much of the history of the system that produced those outcomes
has<br />
been lost. That makes it hard to reason about <em>why</em> those
measurements are the<br />
way they are.</p>
<p>In complex knowledge work, each task often has a distinct
history—different<br />
from other co-temporaneous tasks. Losing this information makes it hard
to<br />
reason about the system. We are reduced to trying to make inferences
from<br />
descriptive statistics of a rapidly changing system. We try to reason
about<br />
this system, shaped by its history, without a way to represent or
reason<br />
about that history. This is difficult to do, and our current tools are
not fit<br />
for this purpose.</p>
<p>This is where the presence calculus begins. While it often starts
from the<br />
same snapshots, the calculus focuses on the time <em>in between</em>:
when the task<br />
was present, where it was present, for how long, and whether its
presence<br />
shifted across people, tools, or systems.</p>
<p>The connective tissue is no longer the task itself, or the steps it
followed,<br />
or who was working on it, but a continuous, observable <em>thread of
presence</em>—<br />
through all of them, moving through time, crossing boundaries—a
mathematical<br />
representation of history.</p>
<p>With the presence calculus, these threads and their interactions
across time<br />
and space can now be measured, dissected, and analyzed as
first-class<br />
constructs—built on a remarkably simple primitive—the presence.</p>
<h1 id="the-heart-of-the-matter">The heart of the matter</h1>
<p>The calculus, at its core, comes down to the difference between the
two<br />
independent statements—“The task started development on Monday” and “The
task<br />
completed development on Friday”—and a single, unified assertion: “The
task<br />
was present in development from Monday through Friday.”</p>
<p>The latter is called a <em>presence</em>, and it is the foundational
building block of the<br />
calculus<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>At first glance, this might not seem like a meaningful
difference.</p>
<p>But treating the presence as the primary object of reasoning—as a
<em>first-class</em><br />
construct—opens up an entirely new space of possibilities, because it
allows<br />
us to apply powerful mathematical tools that exploit the continuity in
time<br />
and the algebra of time intervals to reason about complex assemblages of
presences in a rigorous and structured, and more importantly, computable
way.</p>
<p>Let’s see how by applying it to the simple task work problem
first.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If you read this and think, “is this all it is?” - the
answer is yes. It really is all “it” is. But it turns out to be quite
powerful.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
