<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>intro_to_presence_calculus</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<h1 id="the-presence-calculus-a-gentle-introduction">The Presence
Calculus, <br> A Gentle Introduction</h1>
<p><strong>Dr. Krishna Kumar</strong><br />
<em>The Polaris Advisor Program</em></p>
<h2 id="what-is-the-presence-calculus">What is The Presence
Calculus?</h2>
<p>The Presence Calculus is a new approach for reasoning quantitatively
about the<br />
relationships between things and places in a domain over time.</p>
<p>The primary goal is to support rigorous modeling and principled<br />
decision-making with operational data in complex, business-critical
domains.</p>
<p>A key objective was ensuring that the use of data in such decisions
rests on a<br />
mathematically precise, logically coherent, and epistemically
grounded<br />
foundation.</p>
<p>The presence calculus emerged from a search for better quantitative
tools to<br />
reason about software product development and engineering, where
current<br />
approaches leave much to be desired in all three aspects.</p>
<p>Minimally, the foundational constructs of the calculus bring
mathematical<br />
precision to widely used—but poorly defined—concepts such as flow,
stability,<br />
equilibrium, and coherence in a domain. More importantly, it allows us
to<br />
relate them to business-oriented concerns like delay, cost, revenue,
and<br />
user experience.</p>
<p>As you’ll see, however, the ideas behind the calculus are far more
general,<br />
with potential applications well beyond the software product
development<br />
context it emerged from.</p>
<div style="text-align: center; margin:2em">
<img src="../assets/pcalc/presence_calculus.png" width="600px" />
<div
style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
<pre><code>Figure 1: Key constructs—presences, element trajectories, presence matrix,  
and basis topology</code></pre>
</div>
</div>
<h1 id="the-pitch">The pitch</h1>
<p>We introduce the simple but powerful concept of a
<em>presence</em>.</p>
<p>This lets us reason about time, history and evolution using
techniques from measure theory, topology and complex analysis.</p>
<p>Classical statistics and probability theory often struggle here.
<em>History</em>—the sequence and structure of changes in the domain
over time— is usually fenced off under assumptions like ergodicity,
stationarity, and independence.</p>
<p>However, probability theory and statistic remain very powerful tools
for describing local behavior, identifying patterns and correlations in
this behavior, and modeling uncertainty—all crucial aspects of
meaningful analysis of complex systems.</p>
<p>Our thesis is that to move beyond simple descriptive statistics,
statistical inference and probabilistic models, and start reasoning
about global and long run behavior of complex systems, we need models
that treat time and history as first-class concepts we can reason and
compute with.</p>
<p>This, in turn, lets us apply techniques from disclines such as
stochastic process dynamics, queueing theory, and complex systems
science, to reason holistically about global, long run behavior of
complex systems.</p>
<p>We claim the presence calculus is a novel, constructive approach to
do this - a new and powerful reasoning tool for anyone working with
complex systems.</p>
<p>But this is a bold claim, and it deserves further scrutiny and
validation, and so we invite anyone interested in doing so to
collaborate with us on this open source project.</p>
<h2 id="learning-more-about-the-presence-calculus">Learning more about
The Presence Calculus</h2>
<p>While the calculus was developed with mathematical rigor, an equally
important<br />
goal was not to let mathematics get in the way of understanding the
simple but very powerful and general ideas the calculus embodies<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>In this document, we’ll motivate and introduce the key ideas in the
calculus<br />
informally, with lots of highly simplified examples and allusions
to<br />
illustrate concepts.</p>
<p>It is aimed squarely at the non-technical reader. We’ll also continue
with ongoing informal exposition on our blog<br />
<a href="https://www.polaris-flow-dispatch.com">The Polaris Flow
Dispatch</a>.</p>
<p>We recommend reading and understanding the ideas here before jumping
deeper<br />
into the rest of the documentation at this site, which does get a fair
bit<br />
more dense.</p>
<p>The next level of detail is in the API docs for the <a
href="https://py.pcalc.org">The Presence Calculus<br />
Toolkit</a>. The toolkit is an open source python library that is
designed to provide efficient implementions for all the core concepts in
the presence calculus. In the API documentation, we go into the concepts
at a level of rigor that you’ll need to work with the pcalc API and
apply the concepts. Some mathematical background will be useful here if
you want to develop extensions to the core.</p>
<p>Finally, for those who want to dive deeper into the formal
mathematical<br />
underpinnings of the calculus, we have the theory track, which perhaps
goes<br />
into more detail than most people will need to read or understand, but
is<br />
useful for the mathematically trained to connect the ideas to their
roots in<br />
mainstream mathematics.</p>
<p>Let’s jump in…</p>
<h2 id="why-presence">Why Presence?</h2>
<p>Presence is how reality reveals itself.</p>
<p>We do not perceive the world as disjointed events in time, but rather
as an unfolding—things come into being, endure for a time, and slip
away.</p>
<p>Permanence is just a form of lasting presence. What we call
<em>change</em> is the<br />
movement of presences in and out of our awareness, often set against
that<br />
permanence.</p>
<p>The sense of something being present—or no longer present—is our
most<br />
immediate way of detecting change.</p>
<p>This applies to both the tangible—people, places, and things—and
the<br />
intangible—emotions, feelings, and experiences.</p>
<p>Either way, we reason about the world by reasoning about the
presences and<br />
absences in our environment over time.</p>
<p>The presence calculus begins here. Before we count, measure, compare,
or<br />
optimize, we observe what <em>is</em>.</p>
<p>And what we model is presence.</p>
<h2 id="an-example">An example</h2>
<p>Imagine you see a dollar bill on the sidewalk on your way to get
coffee.<br />
Later, on your way back home, you see it again—still lying in the same
spot.<br />
It would be reasonable for you to assume that the dollar bill was
present<br />
there the whole time.</p>
<p>Of course, that may not be true. Someone might have picked it up in
the<br />
meantime, felt guilty, and quietly returned it. But in the absence of
other<br />
information, your assumption holds: it was there before, and it’s there
now,<br />
so it must have been there in between.</p>
<p>This simple act of inference is something we do all the time. We fill
in gaps,<br />
assume continuity, and reason about what must have been present based on
what<br />
we know from partial glimpses of the world.</p>
<p>The presence calculus gives formal shape to this kind of
inference—and shows<br />
how we can build upon it to <em>reason</em> about presence and
<em>measure</em> its<br />
effects in an environment.</p>
<h2 id="a-software-example">A software example</h2>
<p>Since the ideas here emerged from the software world, let’s begin
with a<br />
mundane, but familiar example: task work in a software team.</p>
<p>By looking closely at how we reason about tasks, we can see how a
subtle shift<br />
to a presence-centered perspective changes not just what we observe, but
what<br />
we measure, and thus can reason about.</p>
<p>We usually reason about task work using <em>events</em> and
<em>snapshots</em> of the state<br />
of a process in time. A task “starts” when it enters development,
and<br />
“finishes” when it’s marked complete. We track “cycle time” by measuring
the<br />
elapsed time between events, “throughput” by counting finish events,
and<br />
“work-in-process” by counting tasks that have started but not yet
finished.</p>
<p>When we look at a Kanban board, we see a point-in-time snapshot of
where tasks<br />
are at that moment—but not how they got there. And by the time we read
a<br />
summary report of how many tasks were finished and how long they took to
go through the process on average, much of the history of the system
that produced those measurements has been lost. That makes it hard to
reason about <em>why</em> those measurements are the way they are.</p>
<p>In complex knowledge work, each task often has a distinct
history—different<br />
from other tasks present at the same time. Losing history makes it hard
to<br />
reason about their interactions and how they impact the global behavior
of the<br />
process.</p>
<p>This problem is not unique to task work. Similar problems exist in
almost all areas of business analysis that rely primarily on descriptive
statistics as the primary measurement tool for system behavior.</p>
<p>We are reduced to trying to make inferences from local
descriptive<br />
statistics —things like cycle times, throughput, and work-in-process
levels- over a rapidly changing process.</p>
<p>We try to reason about a process which is shaped by its history, with
measurement techniques that struggle to represent or reason about that
history. This is difficult to do, and we have no good tools right now
that are fit for<br />
this purpose.</p>
<p>This is where the presence calculus begins.</p>
<p>While it often starts from the same snapshots, the calculus focuses
on the<br />
time <em>in between</em>: when the task was present, where it was
present, for how<br />
long, and whether its presence shifted across people, tools, or
systems.</p>
<p>The connective tissue is no longer the task itself, or the process
steps it<br />
followed, or who was working on it, but a continuous, observable
<em>thread of<br />
presence</em>—through all of them, moving through time, interacting,
crossing boundaries—a mathematical representation of history.</p>
<p>With the presence calculus, these threads and their interactions
across time<br />
and space can now be measured, dissected, and analyzed as
first-class<br />
constructs—built on a remarkably simple primitive—the presence.</p>
<h2 id="the-heart-of-the-matter">The heart of the matter</h2>
<p>At its core, the calculus exploits the difference between the two
independent<br />
statements—“The task started development on Monday” and “The task
completed<br />
development on Friday”—and a single, unified assertion: “The task was
present<br />
in development from Monday through Friday.”</p>
<p>The latter is called a <em>presence</em>, and it is the foundational
building block<br />
of the calculus.</p>
<p>At first glance, this might not seem like a meaningful
difference.</p>
<p>But treating the presence as the primary object of reasoning—as a
<em>first-class</em> construct—opens up an entirely new space of
possibilities.</p>
<p>Specifically, it allows us to apply powerful mathematical tools that
exploit the continuity of time and the algebra of time intervals to
reason about the interactions and emergent assemblages of presences in a
rigorous and structured, and more importantly, computable way.</p>
<h2 id="what-is-a-presence">What is a presence?</h2>
<p>Let’s start by building intuition for this concept we call a
<em>presence</em>.<br />
Consider the statement: “The task <span class="math inline">\(X\)</span>
was in Development from Monday to<br />
Friday.”</p>
<p>In the presence calculus, this would be expressed as a presence of
the form:<br />
“The element <span class="math inline">\(X\)</span> was in boundary
<span class="math inline">\(Y\)</span> from <span
class="math inline">\(t_0\)</span> to <span
class="math inline">\(t_1\)</span> with mass 1.”<br />
Presences are statements about elements (from some domain) being present
in a<br />
boundary (from a defined set of boundaries) over a <em>continuous</em>
period of time,<br />
measured using some time scale.</p>
<p>So why do we say “with mass 1”?</p>
<p>The presence calculus treats time as a physical dimension, much like
space.<br />
Just as matter occupies space, presences occupy time. Just as mass
quantifies<br />
<em>how</em> matter occupies space, the mass of a presence quantifies
<em>how</em> a<br />
presence occupies time.</p>
<p>The statement “The task <span class="math inline">\(X\)</span> was in
Development from Monday through Friday” is<br />
a <strong>binary presence</strong> with a uniform mass of 1 over the
entire duration. The<br />
units of this mass are element-time—in this case, task-days.</p>
<p>Binary presences are sufficient to describe the <em>fact</em> of
presence or absence<br />
of things in places in a domain. These presences always have mass 1 in
whatever<br />
units we use for elements and time.</p>
<h2 id="what-is-the-mass-of-a-presence">What is the mass of a
presence?</h2>
<p>Let’s consider a more detailed set of statements:</p>
<blockquote>
<p>“Task <span class="math inline">\(X\)</span> had 2 developers working
on it from Monday to Wednesday,<br />
3 developers on Thursday, and 1 developer on Friday.”</p>
</blockquote>
<p>These are no longer about just presence, but about the
<em>effects</em> of presence.<br />
They describe the <strong>load</strong> that task <span
class="math inline">\(X\)</span> placed on the Development
boundary<br />
over time.</p>
<p>The units of this presence are developer-days - potentially in a
completely different space from the task, but grounded over the same
time interval as the task.</p>
<p>Here we are saying: “the task being in this boundary over this time
period, had this effect.”</p>
<p>We will describe such presences using a <em>presence density
function,</em> called <span class="math inline">\(\mathsf{load}\)</span>
in this case:</p>
<ul>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Monday}, \text{Wednesday}, 2)\)</span></li>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Thursday}, \text{Thursday}, 3)\)</span></li>
<li><span class="math inline">\((\mathsf{load}, X, \text{Development},
\text{Friday}, \text{Friday}, 1)\)</span></li>
</ul>
<p>Here, <span class="math inline">\(\mathsf{load}(e, b, t)\)</span> is
a time-varying function that takes an<br />
element <span class="math inline">\(e\)</span>, a boundary <span
class="math inline">\(b\)</span>, and a time <span
class="math inline">\(t\)</span>, and returns a real-valued number<br />
describing how much presence is concentrated at that point in time.</p>
<p>The <em>presence mass</em> of such a presence is the total presence
over the<br />
interval <span class="math inline">\([t_0, t_1]\)</span>, defined
as:</p>
<p><span class="math display">\[ \text{mass} = \int_{t_0}^{t_1} f(e, b,
t)\, dt \]</span></p>
<p>where <span class="math inline">\(f\)</span> is the presence density
function <a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<h2 id="presence-density-functions-and-measure-theory">Presence density
functions and measure theory</h2>
<p>Binary presence functions are much easier to understand intuitively,
and we’ll<br />
continue using them in our examples. But the real power of the
presence<br />
calculus comes from generalizing to <em>presence density
functions</em>.</p>
<p>In our earlier example, we interpreted the presence density function
(PDF) as<br />
expressing the <em>load</em> placed on an element at a boundary. But
more generally,<br />
a PDF can be <em>any</em> real-valued function over time. The only
requirement is<br />
that you can interpret <em>presence mass</em>—defined as the integral of
the function<br />
over a finite interval—as a meaningful <em>measure</em> of the effect of
presence in<br />
your domain.</p>
<p>This is where measure theory enters the picture. It’s not essential
to<br />
understand the full technical details, but at its core, measure theory
tells<br />
us which kinds of functions are <em>measurable</em>—in other words,
which functions<br />
can support meaningful accumulation, comparison, and composition of
values.</p>
<p>Measurability gives us the confidence to do things like compute
statistics,<br />
aggregate over elements or boundaries, and compose presence
effects—while<br />
preserving the semantics of the domain. When a PDF is measurable, we
can<br />
treat its values like any other real number and do math over them, as
long as<br />
we carefully respect the units involved.</p>
<p>From our perspective, a presence density function captures a kind
of<br />
measurement that can be <em>accumulated</em> across time and across
presences. This<br />
lets us reason mathematically about presences with confidence—and since
most<br />
of this reasoning will be performed by algorithms, we need
technical<br />
constraints that ensure those calculations are both mathematically valid
and<br />
semantically sound.</p>
<p>To summarize:</p>
<p>A general presence is defined by:</p>
<ul>
<li>a density function <span class="math inline">\(f(e, b,
t)\)</span>,</li>
<li>an element <span class="math inline">\(e\)</span>,</li>
<li>a boundary <span class="math inline">\(b\)</span>,</li>
<li>and a time interval <span class="math inline">\([t_0,
t_1]\)</span>.</li>
</ul>
<p>Its <strong>mass</strong> is the integral of <span
class="math inline">\(f\)</span> over the interval:</p>
<p><span class="math display">\[ \text{mass}(e, b, [t_0, t_1]) =
\int_{t_0}^{t_1} f(e, b, t)\, dt \]</span></p>
<p>This mass captures both <em>that</em> the element was present, and
<em>how</em> it was<br />
present—uniformly, variably, or intermittently—over the time interval of
the presence<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<h2 id="more-examples">More examples</h2>
<p>Let’s firm up our intuition about what presences can describe with a
few more<br />
examples.</p>
<h3 id="work-in-software">“Work” in software</h3>
<p>If you’ve ever written a line of code in your life, you’ve heard the
question:<br />
“When will it be done?” Work in software can be a slippery, fungible
concept—<br />
and the presence calculus offers a useful way to describe it.</p>
<p>We can express the work on a task using a presence density function
whose<br />
value at time <span class="math inline">\(t\)</span> is the
<em>remaining</em> work on the task at that moment.</p>
<p>This lets us model tasks whose duration is uncertain in general, but
whose<br />
remaining duration can be described at any given time—a common scenario
in<br />
software contexts.</p>
<p>A series of presences, where the (non-zero) mass of each presence
corresponds<br />
to the total remaining work over its interval (interpreting the integral
as a<br />
sum), gives us a way to represent <em>work as presence</em>.</p>
<p>Such presences can represent estimates, forecasts, or
confidence-weighted<br />
projections—and as we’ll see shortly, they can be reasoned about and
computed<br />
with just like any other kind of presence.</p>
<h3 id="the-effects-of-interruptions">The effects of interruptions</h3>
<p>Another useful example from the software world illustrates a
different<br />
application of a presence. Let’s assume the boundary in this case is
a<br />
developer, the element is an interruption (defined appropriately in
the<br />
domain), and the presence density function captures the <em>context
switching<br />
cost</em>—measured in lost time—associated with that interruption.</p>
<p>The key insight here is that the <em>effects</em> of the presence
extend beyond the<br />
interval of the interruption itself. This is a classic case of a delayed
or<br />
<em>decaying effect</em>—a pattern that appears frequently in real-world
systems.</p>
<p>The presence density function can be modeled in different ways:</p>
<ul>
<li>As a constant cost: for example, each interruption causes a
fixed<br />
15-minute recovery period, regardless of its duration.<br />
</li>
<li>As a decaying function: the cost is highest at the moment of
interruption<br />
and gradually decreases to zero over a defined recovery window
(e.g.<br />
15 minutes), representing a return to full focus.</li>
</ul>
<p>This approach gives us a precise way to model and reason about
the<br />
<em>aftereffects</em> of events—effects that outlast the events
themselves and<br />
accumulate in subtle but measurable ways over longer timeframes.</p>
<p>In this case, we measured an effect that decayed from a peak, but a
similar<br />
approach can be taken, for example, with a presence density function
that<br />
grows from zero and plateaus over the duration of the presence—such as
the net<br />
increase in revenue due to a released feature.</p>
<p>Used this way, presence density functions give us a powerful tool for
modeling<br />
the impact of binary presences—capturing their downstream or
distributed<br />
effects over time, and reasoning about their relationship over a
shared<br />
timeline.</p>
<p>Another important use case in the same vein is modeling the cost of
delay for a<br />
portfolio-level element—and analyzing its cascading impact across
the<br />
portfolio.</p>
<p>These use cases show that it is possible to analyze not just binary
presences,<br />
but entire chains of influence they exert across a timeline—a key
prerequisite<br />
for reasoning about causality.</p>
<h3 id="self-reported-developer-productivity">Self-reported developer
productivity</h3>
<p>Imagine a developer filling out a simple daily check-in:<br />
“How productive did you feel today?”—scored from 1 to 5, or sketched out
as a<br />
rough curve over the day<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<p>Over a week, this forms a presence density function—not of the
developer in a<br />
place, but of their <em>sense</em> of productivity over time.</p>
<p>These types of presences, representing perceptions, are
powerful—helping<br />
teams track experience, spot early signs of burnout, or correlate
perceived<br />
flow with meetings, environment changes, build failures, or
interruptions.</p>
<hr />
<p>Now, let’s look at some examples outside software development.</p>
<h3 id="browsing-behavior-on-an-e-commerce-site">Browsing behavior on an
e-commerce site</h3>
<p>Imagine a shopper visiting an online store. They spend 90 seconds
browsing<br />
kitchen gadgets, then linger for five full minutes comparing
high-end<br />
headphones, before briefly glancing at a discounted blender.</p>
<p>Each of these interactions can be modeled as a presence: the
shopper’s<br />
(element) attention occupying different parts of the site (boundaries)
over<br />
time. The varying durations reflect interest, and the shifting presence
reveals<br />
patterns of engagement.</p>
<p>By analyzing these presences—where and for how long attention
dwells—we can<br />
begin to understand preferences, intent, and even the likelihood of
conversion<br />
(modeled as a different presence density function).</p>
<h3 id="patient-movement-in-a-hospital">Patient movement in a
hospital</h3>
<p>Consider a patient navigating a hospital stay. They spend the morning
in<br />
radiology, move to a recovery ward for several hours, then are
briefly<br />
transferred to the ICU overnight.</p>
<p>Each location records a presence—when and where the patient was, and
for how<br />
long. These presences can reveal bottlenecks, resource utilization,
and<br />
potential risks.</p>
<p>Over time, analyzing patient presences helps surface patterns in
care<br />
delivery, delays in treatment, and opportunities for improving patient
flow.</p>
<p>These are examples of classic operations management problems
expressed in the<br />
language of the presence calculus. The calculus is well-suited to
modeling<br />
scenarios like these as a base case.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This document is the first step in that direction. We
welcome feedback on how it can be improved,and the concepts clarified.
Please feel free to open a pull request with thoughts, suggestions or
feedback.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>If integration signs in a “gentle” introduction feels
like a bait-and-switch, rest assured, this is the last time you will
need to think of them in this document - <em>provided</em> you accept
the statement that anything that we can do it in presences calculus with
binary presences can also be done with general presence density
functions. Besides, we had to say something about why we call this a
<em>calculus</em>, and this is as good a point to do that as any!<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The way we’ve defined presence density functions and
mass is directly<br />
analogous to how mass is defined for matter occupying space in
physics.</p>
<p>A binary PDF can be thought of as defining a one-dimensional interval
over<br />
time. For a fixed element and boundary, this gives us an area under
the<br />
curve in two dimensions: time vs. density.</p>
<p>If we treat elements and boundaries as additional independent
dimensions,<br />
then the PDF defines a <em>volume</em> in three dimensions, with time as
one axis.</p>
<p>This interpretation—presence as a physical manifestation of density
over<br />
time—is a powerful way to reason intuitively and computationally about
duration, overlap, and accumulation in time.</p>
<p>And when we allow multiple PDFs to interact over the same time
periods, we<br />
begin to model complex, higher-dimensional effects of presence—exactly
the<br />
kind of generality we’ll need when we move beyond simple binary
presences.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The use of a rough curve here is an example of how
presences can encode<br />
continuous inputs more effectively than discrete techniques, thanks to
their<br />
explicit model of time. Forcing a developer to rank their productivity
on a<br />
Likert scale often loses valuable nuance—whereas a fine-grained
presence<br />
captures temporal variation with ease, making it available for
downstream<br />
analysis.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
