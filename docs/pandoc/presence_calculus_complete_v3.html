<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>presence_calculus_complete_v3</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: Georgia, serif;
      font-size: 19px;
      line-height: 1.75;
      background: #fff;
      color: #111;

      /* flex centering */
      display: flex;
      justify-content: center;
    }

    #page {
      max-width: 880px;
      width: 100%;
      padding: 2.5rem 1.5rem;
      box-sizing: border-box;
    }

    h1, h2, h3, h4 {
      font-family: Georgia, serif;
      font-weight: bold;
      margin-top: 2rem;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    p {
      margin: 1.25rem 0;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 2rem auto;
    }

    pre {
      background: #f8f8f8;
      padding: 1rem;
      overflow-x: auto;
      border-radius: 6px;
    }

    code {
      font-family: SFMono-Regular, Consolas, monospace;
      background: #f5f5f5;
      padding: 0.2em 0.4em;
      border-radius: 4px;
    }

    blockquote {
      margin: 2rem 0;
      padding-left: 1rem;
      border-left: 4px solid #ddd;
      color: #666;
      font-style: italic;
    }

    .subtitle, .author, .date {
      color: #666;
      font-size: 1rem;
      margin-top: 0.5rem;
    }

    nav#TOC {
      margin: 2rem 0;
      padding: 1rem;
      border: 1px solid #eee;
      background: #fafafa;
    }
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
  <div id="page">
                <h1
                id="presence-calculus-topology-sheaf-semantics-and-matrix-representations">Presence
                Calculus: Topology, Sheaf Semantics, and Matrix
                Representations</h1>
                <p>This document presents a mathematically coherent view
                of the presence calculus, tracing its topological
                underpinnings and their expression through sheaf theory.
                It addresses practical representations such as the
                presence matrix while ensuring that all definitions are
                compatible with formal mathematical constraints.</p>
                <p>We begin by defining the topology induced by presence
                assertions, then describe how element trajectories arise
                as connected components. We show how the notion of an
                observation window fits within this topological
                framework and explain the relationship between presence
                matrices and the sheaf of presence assertions.</p>
                <h1 id="presence-assertions">Presence Assertions</h1>
                <p>The fundamental object of the presence calculus is
                the <strong>presence assertion</strong>.</p>
                <p>A <strong>presence assertion</strong> is a
                4-tuple:</p>
                <p><span class="math display">\[
                p = (e, b, t_0, t_1)
                \]</span></p>
                <p>where: - <span class="math inline">\(e \in E\)</span>
                is an element (a thing that can be present), - <span
                class="math inline">\(b \in B\)</span> is a boundary (a
                place or context), - <span class="math inline">\([t_0,
                t_1) \subset \mathbb{R}\)</span> is a half-open time
                interval during which <span
                class="math inline">\(e\)</span> is asserted to be
                present in <span class="math inline">\(b\)</span>.</p>
                <h3 id="the-space-of-all-potential-presences">The Space
                of All Potential Presences</h3>
                <p>The set of all <em>possible</em> presence assertions
                is the product space:</p>
                <p><span class="math display">\[
                \mathcal{P}_{\text{all}} = E \times B \times \mathbb{R}
                \times \mathbb{R}
                \]</span></p>
                <p>subject to the constraint that <span
                class="math inline">\(t_0 &lt; t_1\)</span>.</p>
                <h3 id="the-set-of-actual-presences">The Set of Actual
                Presences</h3>
                <p>In any given system or model, only a subset of these
                possible tuples are asserted to hold. This subset is
                denoted:</p>
                <p><span class="math display">\[
                \mathcal{P}_{\text{obs}} \subset
                \mathcal{P}_{\text{all}}
                \]</span></p>
                <p>and is treated as given (e.g., from observation,
                logs, or domain assertions). The presence calculus
                operates entirely on this set of <strong>actual presence
                assertions</strong>.</p>
                <h3
                id="characteristic-function-view-clarification">Characteristic
                Function View (Clarification)</h3>
                <p>While earlier formulations introduced a function:</p>
                <p><span class="math display">\[
                P : E \times B \times \mathbb{R} \times \mathbb{R} \to
                \mathbb{R}
                \]</span></p>
                <p>such a function should be interpreted, if used, as
                the <strong>characteristic function</strong> of the set
                <span
                class="math inline">\(\mathcal{P}_{\text{obs}}\)</span>:</p>
                <p><span class="math display">\[
                P(e, b, t_0, t_1) =
                \begin{cases}
                1 &amp; \text{if } (e, b, t_0, t_1) \in
                \mathcal{P}_{\text{obs}} \\
                0 &amp; \text{otherwise}
                \end{cases}
                \]</span></p>
                <p>This representation is useful for certain forms of
                analysis or aggregation, but the presence assertion
                itself is fundamentally the <strong>tuple</strong> <span
                class="math inline">\((e, b, t_0, t_1)\)</span>, not the
                value of a function.</p>
                <hr />
                <h2 id="practical-interpretation">Practical
                Interpretation</h2>
                <p>A presence assertion is a primitive fact: “Element
                <span class="math inline">\(e\)</span> was present in
                boundary <span class="math inline">\(b\)</span>
                continuously from time <span
                class="math inline">\(t_0\)</span> to <span
                class="math inline">\(t_1\)</span>.” No assumptions are
                made about how this assertion was derived—whether from
                physical sensors, logs, or logical inference. The
                presence calculus treats all such assertions as
                axiomatic inputs. We will use the example below to
                illustrate how we define and construct the topology of
                presences assertions over a domain.</p>
                <div style="text-align: center; margin:2em">
                <img src="../assets/pandoc/presence_topology_example.png" width="600px" />
                <div
                style="font-size: 0.9em; color: #555; margin-top: 1em; margin-bottom: 1em;">
                <pre><code>Figure 1: A set of presence assertions over a domain</code></pre>
                </div>
                </div>
                <hr />
                <hr />
                <h1 id="presence-topology">Presence Topology</h1>
                <p>Let <span class="math inline">\(D\)</span> be the
                domain of entities and boundaries, and let presence
                assertions be defined over the space <span
                class="math inline">\(E \times B \times \mathbb{R}
                \times \mathbb{R}\)</span>, where each presence
                assertion corresponds to a tuple <span
                class="math inline">\((e, b, t_0, t_1)\)</span>.</p>
                <p>We define a topology <span
                class="math inline">\(\mathcal{T}\)</span> on this space
                by specifying a basis of open sets. Each basis element
                is defined by a tuple of the form:</p>
                <p><span class="math display">\[
                U_{e,b,I} = \{ (e&#39;, b&#39;, t_0&#39;, t_1&#39;) \mid
                e&#39; = e, b&#39; = b, [t_0&#39;, t_1&#39;) \subset I
                \}
                \]</span></p>
                <p>where <span class="math inline">\(e \in E\)</span>,
                <span class="math inline">\(b \in B\)</span>, and <span
                class="math inline">\(I = (a, b) \subset
                \mathbb{R}\)</span> is an open interval on the time
                axis.</p>
                <p>The collection of all such <span
                class="math inline">\(U_{e,b,I}\)</span> for all <span
                class="math inline">\(e\)</span>, <span
                class="math inline">\(b\)</span>, and open intervals
                <span class="math inline">\(I\)</span> forms a basis for
                the presence topology <span
                class="math inline">\(\mathcal{T}\)</span>.</p>
                <h2 id="intuition">Intuition</h2>
                <p>Each basis element isolates a specific element and
                boundary, and considers all presence intervals entirely
                contained within a given time window. This yields a
                natural notion of “local neighborhood” around a
                presence, and allows us to define continuity,
                clustering, and flow across the space of presences.</p>
                <h2 id="use">Use</h2>
                <p>This topology underpins definitions of co-presence,
                continuity, and topological observables such as
                connected components, accumulation zones, and
                persistence regions.</p>
                <hr />
                <h1
                id="topological-basis-for-presence-assertions">Topological
                Basis for Presence Assertions</h1>
                <p>Based on the provided presence diagram, we define the
                topological basis over the space <span
                class="math inline">\(E \times B \times \mathbb{R}
                \times \mathbb{R}\)</span> using the presence
                calculus.</p>
                <h2 id="observed-presence-assertions">Observed Presence
                Assertions</h2>
                <p>Each presence assertion corresponds to a 4-tuple
                <span class="math inline">\((e, b, t_0, t_1)\)</span>,
                where: - <span class="math inline">\(e\)</span> is an
                entity (element), - <span
                class="math inline">\(b\)</span> is a boundary, - <span
                class="math inline">\([t_0, t_1)\)</span> is the
                half-open time interval of presence.</p>
                <p>From the diagram, we identify the following presence
                assertions:</p>
                <table>
                <thead>
                <tr>
                <th>Element</th>
                <th>Boundary</th>
                <th>Interval</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                <td>e1</td>
                <td>B1</td>
                <td>[1, 6)</td>
                </tr>
                <tr>
                <td>e3</td>
                <td>B1</td>
                <td>[3, 10)</td>
                </tr>
                <tr>
                <td>e1</td>
                <td>B1</td>
                <td>[11, 13)</td>
                </tr>
                <tr>
                <td>e1</td>
                <td>B2</td>
                <td>[1, 6)</td>
                </tr>
                <tr>
                <td>e4</td>
                <td>B2</td>
                <td>[3, 10)</td>
                </tr>
                <tr>
                <td>e1</td>
                <td>B2</td>
                <td>[11, 13)</td>
                </tr>
                </tbody>
                </table>
                <h2 id="topological-basis-construction">Topological
                Basis Construction</h2>
                <p>We define a topology <span
                class="math inline">\(\mathcal{T}\)</span> on the
                presence space by specifying a basis of open sets. Each
                basis element is of the form:</p>
                <p><span class="math display">\[
                U_{e,b,I} = \{ (e&#39;, b&#39;, t_0&#39;, t_1&#39;) \mid
                e&#39; = e, b&#39; = b, [t_0&#39;, t_1&#39;) \subset I
                \}
                \]</span></p>
                <p>where <span class="math inline">\(I \subset
                \mathbb{R}\)</span> is an open interval containing the
                presence interval <span class="math inline">\([t_0,
                t_1)\)</span>.</p>
                <h2 id="example-basis-elements">Example Basis
                Elements</h2>
                <ul>
                <li><span class="math inline">\(U_{e1, B1, (0.9,\
                6.1)}\)</span></li>
                <li><span class="math inline">\(U_{e3, B1, (2.9,\
                10.1)}\)</span></li>
                <li><span class="math inline">\(U_{e1, B1, (10.9,\
                13.1)}\)</span></li>
                <li><span class="math inline">\(U_{e1, B2, (0.9,\
                6.1)}\)</span></li>
                <li><span class="math inline">\(U_{e4, B2, (2.9,\
                10.1)}\)</span></li>
                <li><span class="math inline">\(U_{e1, B2, (10.9,\
                13.1)}\)</span></li>
                </ul>
                <p>Each basis element defines a neighborhood around a
                specific element in a specific boundary, over an open
                interval containing a full presence span.</p>
                <h2 id="interpretation">Interpretation</h2>
                <p>These basis elements allow us to reason about local
                neighborhoods of presence, enabling analysis of
                continuity, clustering, transitions, and proximity in
                presence space.</p>
                <h1
                id="from-topological-basis-to-connected-components-and-element-trajectories">From
                Topological Basis to Connected Components and Element
                Trajectories</h1>
                <h2 id="connecting-presences">Connecting Presences</h2>
                <p>Two presence assertions are topologically connected
                if they: - Share the same element <span
                class="math inline">\(e\)</span> - Have overlapping or
                adjacent time intervals - Possibly occur in different
                boundaries</p>
                <p>By linking such assertions through overlapping basis
                elements, we define connected components in the presence
                topology.</p>
                <h2 id="example">Example</h2>
                <table>
                <thead>
                <tr>
                <th>Element</th>
                <th>Boundary</th>
                <th>Interval</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                <td>e1</td>
                <td>B1</td>
                <td>[1, 6)</td>
                </tr>
                <tr>
                <td>e1</td>
                <td>B1</td>
                <td>[6, 10)</td>
                </tr>
                <tr>
                <td>e1</td>
                <td>B2</td>
                <td>[10, 13)</td>
                </tr>
                </tbody>
                </table>
                <p>These form a single connected component for <span
                class="math inline">\(e1\)</span> across boundaries.</p>
                <p>Other elements (e2, e3, e4) have isolated
                components.</p>
                <h2 id="element-trajectories">Element Trajectories</h2>
                <p>A <strong>maximal connected component</strong> of
                presence assertions for a given element defines its
                <strong>trajectory</strong> through time and space.</p>
                <p>Trajectories can span multiple boundaries and time
                intervals and form the structural basis of presence
                dynamics.</p>
                <hr />
                <h1
                id="topological-foundations-and-sheaf-semantics-of-the-presence-calculus">Topological
                Foundations and Sheaf Semantics of the presence
                calculus</h1>
                <h2 id="observation-windows-and-open-sets">Observation
                Windows and Open Sets</h2>
                <p>Observation windows of the form <span
                class="math inline">\(E&#39; \times B&#39; \times [t_0,
                t_1)\)</span> are not open in the base topology.
                Instead, we use open covers formed from the basis:</p>
                <p><span class="math display">\[
                \mathcal{U} = \{ U_{e,b,(t_i - \epsilon, t_i +
                \epsilon)} \}
                \]</span></p>
                <h2 id="from-pre-sheaf-to-sheaf">From Pre-sheaf to
                Sheaf</h2>
                <p>A <strong>pre-sheaf</strong> <span
                class="math inline">\(\mathcal{P}\)</span> over the
                space <span class="math inline">\(X = E \times B \times
                \mathbb{R} \times \mathbb{R}\)</span> is defined as:</p>
                <ul>
                <li><span class="math inline">\(\mathcal{P}(U)\)</span>
                = all presence assertions <span
                class="math inline">\((e, b, t_0, t_1) \in
                U\)</span></li>
                <li>Restriction: <span class="math inline">\(\rho^U_V(S)
                = S \cap V\)</span></li>
                </ul>
                <h3 id="sheaf-conditions">Sheaf Conditions</h3>
                <ul>
                <li><strong>Locality</strong>: If <span
                class="math inline">\(s_i = s_j\)</span> on overlaps,
                they represent the same global section</li>
                <li><strong>Gluing</strong>: Compatible local sections
                <span class="math inline">\(s_i\)</span> over <span
                class="math inline">\(U_i\)</span> glue uniquely to a
                global <span class="math inline">\(s \in
                \mathcal{P}(U)\)</span></li>
                </ul>
                <h2 id="the-gluing-operator">The Gluing Operator</h2>
                <p>In the presence calculus, the <strong>gluing
                operator</strong> formalizes the process by which local
                presence assertions—defined over overlapping open
                subsets of presence space—are combined into a coherent,
                global trajectory.</p>
                <p>This is the constructive content of the sheaf gluing
                axiom.</p>
                <h3 id="definition">Definition</h3>
                <p>Let <span class="math inline">\(\mathcal{P}\)</span>
                be the sheaf of presence assertions over the topological
                space <span class="math inline">\(X = E \times B \times
                \mathbb{R} \times \mathbb{R}\)</span>, and let <span
                class="math inline">\(\{ U_i \}_{i \in I}\)</span> be an
                open cover of <span class="math inline">\(U \subseteq
                X\)</span>.</p>
                <p>Suppose we have a family of local sections <span
                class="math inline">\(\{ s_i \in \mathcal{P}(U_i)
                \}\)</span> such that:</p>
                <p><span class="math display">\[
                \forall i, j \in I: \quad s_i|_{U_i \cap U_j} =
                s_j|_{U_i \cap U_j}
                \]</span></p>
                <p>Then the <strong>gluing operator</strong> is a
                function:</p>
                <p><span class="math display">\[
                \text{glue} : \prod_{i \in I} \mathcal{P}(U_i) \to
                \mathcal{P}(U)
                \]</span></p>
                <p>such that:</p>
                <p><span class="math display">\[
                \text{glue}(\{ s_i \}) = s \quad \text{where } s|_{U_i}
                = s_i \text{ for all } i
                \]</span></p>
                <p>This operator returns the unique global section <span
                class="math inline">\(s\)</span> whose restriction to
                each <span class="math inline">\(U_i\)</span> is the
                given local section <span
                class="math inline">\(s_i\)</span>.</p>
                <h3 id="interpretation-1">Interpretation</h3>
                <p>The glue operator is the formal mechanism that
                reconstructs a continuous trajectory from overlapping
                presence assertions that agree on their overlaps.</p>
                <p>In implementation terms, it merges sequences of
                presence assertions—across time and boundaries—into a
                <strong>connected component</strong>, or a
                <strong>maximal presence trajectory</strong>.</p>
                <hr />
                <h1 id="presence-matrix-and-sheaf-restriction">Presence
                Matrix and Sheaf Restriction</h1>
                <p>In the presence calculus, the <strong>presence
                matrix</strong> is a concrete, computable representation
                of presence assertions restricted to an
                <strong>observation window</strong>.</p>
                <h2 id="observation-window-as-an-open-set">Observation
                Window as an Open Set</h2>
                <p>An observation window is modeled as:</p>
                <p><span class="math display">\[
                U = E&#39; \times B&#39; \times [t_0, t_1)
                \]</span></p>
                <p>However, this is not open in the base topology <span
                class="math inline">\(\mathcal{T}\)</span> because: -
                <span class="math inline">\([t_0, t_1)\)</span> is not
                open in <span class="math inline">\(\mathbb{R}\)</span>
                - Arbitrary subsets <span class="math inline">\(E&#39;
                \subseteq E\)</span> and <span
                class="math inline">\(B&#39; \subseteq B\)</span> are
                not open unless <span class="math inline">\(E\)</span>
                and <span class="math inline">\(B\)</span> have the
                discrete topology</p>
                <h3 id="resolution">Resolution</h3>
                <p>We interpret an observation window as being covered
                by open sets of the form:</p>
                <p><span class="math display">\[
                U_{e,b,(t_i - \epsilon, t_i + \epsilon)}
                \]</span></p>
                <p>This allows us to treat the presence matrix as a
                discrete approximation of a restriction of the sheaf to
                an open cover.</p>
                <h2 id="presence-matrix-definition">Presence Matrix
                Definition</h2>
                <p>Let <span class="math inline">\(\{t_i\}\)</span> be a
                discrete time grid in <span class="math inline">\([t_0,
                t_1)\)</span>. The matrix:</p>
                <p><span class="math display">\[
                P_{e,b}(t_i) =
                \begin{cases}
                1 &amp; \text{if } (e, b, t_i) \text{ lies within a
                presence assertion} \\
                0 &amp; \text{otherwise}
                \end{cases}
                \]</span></p>
                <p>encodes the observed presence at that time step.</p>
                <h2 id="summary">Summary</h2>
                <p>The presence matrix represents a <strong>sampled
                restriction</strong> of the sheaf over an open cover of
                a bounded domain. It enables computation of metrics like
                residence time, flow rate, and co-presence.</p>
                <p>The presence matrix samples values from sections over
                neighborhoods in a grid covering a bounded domain.</p>
                <p>It is not a literal sheaf section but a discrete
                approximation using open set evaluations.</p>
      </div>
</body>
</html>
