# -*- coding: utf-8 -*-
# Copyright (c) 2025 Krishna Kumar
# SPDX-License-Identifier: MIT
"""
The `BasisTopology` class defines a topological structure over a set of presences—
interval-based assertions of an element’s presence on a boundary. This topology enables
reasoning about continuity, connectedness, and neighborhood relationships among presences,
without assuming any geometric structure.

---

## Intuition

A topology tells us which subsets of a space are considered "open"—intuitively, these
are the sets where you can move slightly without falling out of the set. In our case, the space
consists of presences, each defined over a time interval on a particular boundary.

A topology can be generated from a collection of these open sets, called a **basis**.
Each basis element represents a minimal unit of observable presence, such as a single
presence interval or a region formed by intersections and unions of intervals of presence.

With this structure, we can:

- Define neighborhoods around a presence,
- Construct connected components or trajectories of an element,
- Analyze continuity and coverage properties of the observation,
- Build sheaf structures over local observations.

---

## Formal Definition

Let $P$ be a set of presence assertions, each of the form:

$$
(e, b, t_0, t_1)
$$

where:

- $e \\\in E$: the element present,
- $b \\\in B$: the boundary where presence is observed,
- $[t_0, t_1) \\\subset \\\mathbb{R}$: the half-open time interval of presence.

A **basis** $\\\mathcal{B}$ over $P$ is a collection of subsets of $P$ such that:

1. For each $p \\\in P$, there exists some $B \\\in \\\mathcal{B}$ with $p \\\in B$,
2. If $p \\\in B_1 \\\cap B_2$, then there exists $B_3 \\\in \\\mathcal{B}$ such that
   $p \\\in B_3 \\\subset B_1 \\\cap B_2$.

The topology $\\\mathcal{T}$ generated by $\\\mathcal{B}$ is the set of all unions
of basis sets.

---

## Applications

This structure underlies more advanced constructions such as:

- **Connected trajectories**: identifying maximal paths of an element through multiple boundaries over time.
- **Presence matrices**: capturing observable structure over a timescale and supporting topological invariants
  across time scales.
- **Simplicial complexes**: revealing higher-dimensional intersections between boundaries where elements are
  simultaneously present, enabling analysis of boundary relationships and topological features
  like presence clusters and holes induced by element co-presence.
- **Sheaves of presence assertions**: supporting the gluing of local observations into globally coherent structures.

The `BasisTopology` class provides methods to define, traverse, and query this topology
efficiently over arbitrary collections of presences defined over the domain.
"""

from collections import defaultdict
from typing import Iterable, Tuple
from sortedcontainers import SortedSet
from .presence import PresenceAssertion, EMPTY_PRESENCE


class BasisTopology:
    """
    The foundational topology generated by a set of presence assertions.

    Presences are treated as basis elements defining basic open sets.
    Internally, presences are grouped into sorted open covers per (element, boundary)
    and exposed through join, closure, and overlap operations.
    """

    def __init__(self, presences: Iterable[PresenceAssertion]) -> None:
        """
        Initializes the topology from a set of presences.

        Internally maintains a SortedSet for each (element, boundary) pair,
        ordered by onset_time for efficient merge and overlap operations.
        """
        self.cover_index: dict[Tuple, SortedSet[PresenceAssertion]] = defaultdict(
            lambda: SortedSet(key=presence_sort_key)
        )

        for p in presences:
            key = (p.element, p.boundary)
            self.cover_index[key].add(p)

    def get_cover(self, element, boundary) -> SortedSet[PresenceAssertion]:
        """
        Returns the open cover for a given (element, boundary) pair.
        """
        return self.cover_index.get((element, boundary), SortedSet(key=presence_sort_key))

    @staticmethod
    def join(p1: PresenceAssertion, p2: PresenceAssertion) -> PresenceAssertion:
        """
        Returns the join of two basis elements if they overlap or touch in time.
        Returns EMPTY_PRESENCE if the presences are disjoint or incompatible.
        """
        if (p1.element, p1.boundary) != (p2.element, p2.boundary):
            return EMPTY_PRESENCE

        if p1.reset_time < p2.onset_time != float("-inf") and p1.reset_time != float("inf"):
            return EMPTY_PRESENCE
        if p2.reset_time < p1.onset_time != float("-inf") and p2.reset_time != float("inf"):
            return EMPTY_PRESENCE

        return PresenceAssertion(
            element=p1.element,
            boundary=p1.boundary,
            onset_time=min(p1.onset_time, p2.onset_time),
            reset_time=max(p1.reset_time, p2.reset_time),
            provenance="join",
        )

    def closure(self) -> set[PresenceAssertion]:
        """
        Computes the closure under join for each cover.

        Returns a deduplicated set of merged presences that cover the same regions
        as the original topology, but without adjacent overlaps.
        """
        closed = set()

        for key, cover in self.cover_index.items():
            merged_cover = []
            for p in cover:
                if not merged_cover:
                    merged_cover.append(p)
                    continue

                last = merged_cover[-1]
                j = self.join(last, p)

                if j is not EMPTY_PRESENCE:
                    merged_cover[-1] = j
                else:
                    merged_cover.append(p)

            closed.update(merged_cover)

        return closed

    def find_overlapping(self, presence: PresenceAssertion) -> list[PresenceAssertion]:
        """
        Finds all presences in the same cover that overlap with the given presence.

        This is a linear scan from the first potentially overlapping point onward,
        relying on the sorted order of onset_time.
        """
        key = (presence.element, presence.boundary)
        cover = self.cover_index.get(key, SortedSet(key=presence_sort_key))
        overlapping = []

        for p in cover.irange(minimum=None, maximum=None):
            if p.onset_time >= presence.reset_time:
                break
            if p.reset_time > presence.onset_time:
                overlapping.append(p)

        return overlapping

    def __iter__(self):
        for cover in self.cover_index.values():
            yield from cover


def presence_sort_key(p: PresenceAssertion) -> float:
    """The default sort key for presences in an open cover is onset_time"""
    return p.onset_time
